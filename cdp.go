// Code generated by cdpgen; DO NOT EDIT!

package cdp

import (
	"context"

	"github.com/mafredri/cdp/cdpcmd"
	"github.com/mafredri/cdp/cdpevent"
	"github.com/mafredri/cdp/cdptype"
	"github.com/mafredri/cdp/rpcc"
)

// The Accessibility domain.
type Accessibility interface {
	// Command GetPartialAXTree
	//
	// Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
	GetPartialAXTree(context.Context, *cdpcmd.AccessibilityGetPartialAXTreeArgs) (*cdpcmd.AccessibilityGetPartialAXTreeReply, error)
}

// accessibilityDomain implements the Accessibility domain.
type accessibilityDomain struct{ conn *rpcc.Conn }

func (d *accessibilityDomain) GetPartialAXTree(ctx context.Context, args *cdpcmd.AccessibilityGetPartialAXTreeArgs) (reply *cdpcmd.AccessibilityGetPartialAXTreeReply, err error) {
	reply = new(cdpcmd.AccessibilityGetPartialAXTreeReply)

	err = rpcc.Invoke(ctx, cdpcmd.AccessibilityGetPartialAXTree.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Accessibility", Op: "GetPartialAXTree", Err: err}
	}
	return
}

// NewAccessibilityGetPartialAXTreeArgs initializes the arguments for GetPartialAXTree.
func NewAccessibilityGetPartialAXTreeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.AccessibilityGetPartialAXTreeArgs {
	args := new(cdpcmd.AccessibilityGetPartialAXTreeArgs)
	args.NodeID = nodeID
	return args
}

// The Animation domain.
type Animation interface {
	// Command Enable
	//
	// Enables animation domain notifications.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables animation domain notifications.
	Disable(context.Context) error

	// Command GetPlaybackRate
	//
	// Gets the playback rate of the document timeline.
	GetPlaybackRate(context.Context) (*cdpcmd.AnimationGetPlaybackRateReply, error)

	// Command SetPlaybackRate
	//
	// Sets the playback rate of the document timeline.
	SetPlaybackRate(context.Context, *cdpcmd.AnimationSetPlaybackRateArgs) error

	// Command GetCurrentTime
	//
	// Returns the current time of the an animation.
	GetCurrentTime(context.Context, *cdpcmd.AnimationGetCurrentTimeArgs) (*cdpcmd.AnimationGetCurrentTimeReply, error)

	// Command SetPaused
	//
	// Sets the paused state of a set of animations.
	SetPaused(context.Context, *cdpcmd.AnimationSetPausedArgs) error

	// Command SetTiming
	//
	// Sets the timing of an animation node.
	SetTiming(context.Context, *cdpcmd.AnimationSetTimingArgs) error

	// Command SeekAnimations
	//
	// Seek a set of animations to a particular time within each animation.
	SeekAnimations(context.Context, *cdpcmd.AnimationSeekAnimationsArgs) error

	// Command ReleaseAnimations
	//
	// Releases a set of animations to no longer be manipulated.
	ReleaseAnimations(context.Context, *cdpcmd.AnimationReleaseAnimationsArgs) error

	// Command ResolveAnimation
	//
	// Gets the remote object of the Animation.
	ResolveAnimation(context.Context, *cdpcmd.AnimationResolveAnimationArgs) (*cdpcmd.AnimationResolveAnimationReply, error)

	// Event AnimationCreated
	//
	// Event for each animation that has been created.
	AnimationCreated(context.Context) (cdpevent.AnimationCreatedClient, error)

	// Event AnimationStarted
	//
	// Event for animation that has been started.
	AnimationStarted(context.Context) (cdpevent.AnimationStartedClient, error)

	// Event AnimationCanceled
	//
	// Event for when an animation has been cancelled.
	AnimationCanceled(context.Context) (cdpevent.AnimationCanceledClient, error)
}

// animationDomain implements the Animation domain.
type animationDomain struct{ conn *rpcc.Conn }

func (d *animationDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.AnimationEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "Enable", Err: err}
	}
	return
}

func (d *animationDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.AnimationDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "Disable", Err: err}
	}
	return
}

func (d *animationDomain) GetPlaybackRate(ctx context.Context) (reply *cdpcmd.AnimationGetPlaybackRateReply, err error) {
	reply = new(cdpcmd.AnimationGetPlaybackRateReply)

	err = rpcc.Invoke(ctx, cdpcmd.AnimationGetPlaybackRate.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "GetPlaybackRate", Err: err}
	}
	return
}

func (d *animationDomain) SetPlaybackRate(ctx context.Context, args *cdpcmd.AnimationSetPlaybackRateArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.AnimationSetPlaybackRate.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "SetPlaybackRate", Err: err}
	}
	return
}

// NewAnimationSetPlaybackRateArgs initializes the arguments for SetPlaybackRate.
func NewAnimationSetPlaybackRateArgs(playbackRate float64) *cdpcmd.AnimationSetPlaybackRateArgs {
	args := new(cdpcmd.AnimationSetPlaybackRateArgs)
	args.PlaybackRate = playbackRate
	return args
}

func (d *animationDomain) GetCurrentTime(ctx context.Context, args *cdpcmd.AnimationGetCurrentTimeArgs) (reply *cdpcmd.AnimationGetCurrentTimeReply, err error) {
	reply = new(cdpcmd.AnimationGetCurrentTimeReply)

	err = rpcc.Invoke(ctx, cdpcmd.AnimationGetCurrentTime.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "GetCurrentTime", Err: err}
	}
	return
}

// NewAnimationGetCurrentTimeArgs initializes the arguments for GetCurrentTime.
func NewAnimationGetCurrentTimeArgs(id string) *cdpcmd.AnimationGetCurrentTimeArgs {
	args := new(cdpcmd.AnimationGetCurrentTimeArgs)
	args.ID = id
	return args
}

func (d *animationDomain) SetPaused(ctx context.Context, args *cdpcmd.AnimationSetPausedArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.AnimationSetPaused.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "SetPaused", Err: err}
	}
	return
}

// NewAnimationSetPausedArgs initializes the arguments for SetPaused.
func NewAnimationSetPausedArgs(animations []string, paused bool) *cdpcmd.AnimationSetPausedArgs {
	args := new(cdpcmd.AnimationSetPausedArgs)
	args.Animations = animations
	args.Paused = paused
	return args
}

func (d *animationDomain) SetTiming(ctx context.Context, args *cdpcmd.AnimationSetTimingArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.AnimationSetTiming.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "SetTiming", Err: err}
	}
	return
}

// NewAnimationSetTimingArgs initializes the arguments for SetTiming.
func NewAnimationSetTimingArgs(animationID string, duration float64, delay float64) *cdpcmd.AnimationSetTimingArgs {
	args := new(cdpcmd.AnimationSetTimingArgs)
	args.AnimationID = animationID
	args.Duration = duration
	args.Delay = delay
	return args
}

func (d *animationDomain) SeekAnimations(ctx context.Context, args *cdpcmd.AnimationSeekAnimationsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.AnimationSeekAnimations.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "SeekAnimations", Err: err}
	}
	return
}

// NewAnimationSeekAnimationsArgs initializes the arguments for SeekAnimations.
func NewAnimationSeekAnimationsArgs(animations []string, currentTime float64) *cdpcmd.AnimationSeekAnimationsArgs {
	args := new(cdpcmd.AnimationSeekAnimationsArgs)
	args.Animations = animations
	args.CurrentTime = currentTime
	return args
}

func (d *animationDomain) ReleaseAnimations(ctx context.Context, args *cdpcmd.AnimationReleaseAnimationsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.AnimationReleaseAnimations.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "ReleaseAnimations", Err: err}
	}
	return
}

// NewAnimationReleaseAnimationsArgs initializes the arguments for ReleaseAnimations.
func NewAnimationReleaseAnimationsArgs(animations []string) *cdpcmd.AnimationReleaseAnimationsArgs {
	args := new(cdpcmd.AnimationReleaseAnimationsArgs)
	args.Animations = animations
	return args
}

func (d *animationDomain) ResolveAnimation(ctx context.Context, args *cdpcmd.AnimationResolveAnimationArgs) (reply *cdpcmd.AnimationResolveAnimationReply, err error) {
	reply = new(cdpcmd.AnimationResolveAnimationReply)

	err = rpcc.Invoke(ctx, cdpcmd.AnimationResolveAnimation.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Animation", Op: "ResolveAnimation", Err: err}
	}
	return
}

// NewAnimationResolveAnimationArgs initializes the arguments for ResolveAnimation.
func NewAnimationResolveAnimationArgs(animationID string) *cdpcmd.AnimationResolveAnimationArgs {
	args := new(cdpcmd.AnimationResolveAnimationArgs)
	args.AnimationID = animationID
	return args
}

func (d *animationDomain) AnimationCreated(ctx context.Context) (cdpevent.AnimationCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.AnimationCreated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &animationAnimationCreatedClient{Stream: s}, nil
}

// animationAnimationCreatedClient implements AnimationCreatedClient.
type animationAnimationCreatedClient struct{ rpcc.Stream }

func (c *animationAnimationCreatedClient) Recv() (*cdpevent.AnimationCreatedReply, error) {
	event := new(cdpevent.AnimationCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Animation", Op: "AnimationCreated Recv", Err: err}
	}
	return event, nil
}

func (d *animationDomain) AnimationStarted(ctx context.Context) (cdpevent.AnimationStartedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.AnimationStarted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &animationAnimationStartedClient{Stream: s}, nil
}

// animationAnimationStartedClient implements AnimationStartedClient.
type animationAnimationStartedClient struct{ rpcc.Stream }

func (c *animationAnimationStartedClient) Recv() (*cdpevent.AnimationStartedReply, error) {
	event := new(cdpevent.AnimationStartedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Animation", Op: "AnimationStarted Recv", Err: err}
	}
	return event, nil
}

func (d *animationDomain) AnimationCanceled(ctx context.Context) (cdpevent.AnimationCanceledClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.AnimationCanceled.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &animationAnimationCanceledClient{Stream: s}, nil
}

// animationAnimationCanceledClient implements AnimationCanceledClient.
type animationAnimationCanceledClient struct{ rpcc.Stream }

func (c *animationAnimationCanceledClient) Recv() (*cdpevent.AnimationCanceledReply, error) {
	event := new(cdpevent.AnimationCanceledReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Animation", Op: "AnimationCanceled Recv", Err: err}
	}
	return event, nil
}

// The ApplicationCache domain.
type ApplicationCache interface {
	// Command GetFramesWithManifests
	//
	// Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache.
	GetFramesWithManifests(context.Context) (*cdpcmd.ApplicationCacheGetFramesWithManifestsReply, error)

	// Command Enable
	//
	// Enables application cache domain notifications.
	Enable(context.Context) error

	// Command GetManifestForFrame
	//
	// Returns manifest URL for document in the given frame.
	GetManifestForFrame(context.Context, *cdpcmd.ApplicationCacheGetManifestForFrameArgs) (*cdpcmd.ApplicationCacheGetManifestForFrameReply, error)

	// Command GetApplicationCacheForFrame
	//
	// Returns relevant application cache data for the document in given frame.
	GetApplicationCacheForFrame(context.Context, *cdpcmd.ApplicationCacheGetApplicationCacheForFrameArgs) (*cdpcmd.ApplicationCacheGetApplicationCacheForFrameReply, error)

	// Event ApplicationCacheStatusUpdated
	//
	//
	ApplicationCacheStatusUpdated(context.Context) (cdpevent.ApplicationCacheStatusUpdatedClient, error)

	// Event NetworkStateUpdated
	//
	//
	NetworkStateUpdated(context.Context) (cdpevent.ApplicationCacheNetworkStateUpdatedClient, error)
}

// applicationcacheDomain implements the ApplicationCache domain.
type applicationcacheDomain struct{ conn *rpcc.Conn }

func (d *applicationcacheDomain) GetFramesWithManifests(ctx context.Context) (reply *cdpcmd.ApplicationCacheGetFramesWithManifestsReply, err error) {
	reply = new(cdpcmd.ApplicationCacheGetFramesWithManifestsReply)

	err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheGetFramesWithManifests.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "ApplicationCache", Op: "GetFramesWithManifests", Err: err}
	}
	return
}

func (d *applicationcacheDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ApplicationCache", Op: "Enable", Err: err}
	}
	return
}

func (d *applicationcacheDomain) GetManifestForFrame(ctx context.Context, args *cdpcmd.ApplicationCacheGetManifestForFrameArgs) (reply *cdpcmd.ApplicationCacheGetManifestForFrameReply, err error) {
	reply = new(cdpcmd.ApplicationCacheGetManifestForFrameReply)

	err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheGetManifestForFrame.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "ApplicationCache", Op: "GetManifestForFrame", Err: err}
	}
	return
}

// NewApplicationCacheGetManifestForFrameArgs initializes the arguments for GetManifestForFrame.
func NewApplicationCacheGetManifestForFrameArgs(frameID cdptype.PageFrameID) *cdpcmd.ApplicationCacheGetManifestForFrameArgs {
	args := new(cdpcmd.ApplicationCacheGetManifestForFrameArgs)
	args.FrameID = frameID
	return args
}

func (d *applicationcacheDomain) GetApplicationCacheForFrame(ctx context.Context, args *cdpcmd.ApplicationCacheGetApplicationCacheForFrameArgs) (reply *cdpcmd.ApplicationCacheGetApplicationCacheForFrameReply, err error) {
	reply = new(cdpcmd.ApplicationCacheGetApplicationCacheForFrameReply)

	err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheGetApplicationCacheForFrame.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "ApplicationCache", Op: "GetApplicationCacheForFrame", Err: err}
	}
	return
}

// NewApplicationCacheGetApplicationCacheForFrameArgs initializes the arguments for GetApplicationCacheForFrame.
func NewApplicationCacheGetApplicationCacheForFrameArgs(frameID cdptype.PageFrameID) *cdpcmd.ApplicationCacheGetApplicationCacheForFrameArgs {
	args := new(cdpcmd.ApplicationCacheGetApplicationCacheForFrameArgs)
	args.FrameID = frameID
	return args
}

func (d *applicationcacheDomain) ApplicationCacheStatusUpdated(ctx context.Context) (cdpevent.ApplicationCacheStatusUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ApplicationCacheStatusUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &applicationcacheApplicationCacheStatusUpdatedClient{Stream: s}, nil
}

// applicationcacheApplicationCacheStatusUpdatedClient implements ApplicationCacheStatusUpdatedClient.
type applicationcacheApplicationCacheStatusUpdatedClient struct{ rpcc.Stream }

func (c *applicationcacheApplicationCacheStatusUpdatedClient) Recv() (*cdpevent.ApplicationCacheStatusUpdatedReply, error) {
	event := new(cdpevent.ApplicationCacheStatusUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "ApplicationCache", Op: "ApplicationCacheStatusUpdated Recv", Err: err}
	}
	return event, nil
}

func (d *applicationcacheDomain) NetworkStateUpdated(ctx context.Context) (cdpevent.ApplicationCacheNetworkStateUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ApplicationCacheNetworkStateUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &applicationcacheNetworkStateUpdatedClient{Stream: s}, nil
}

// applicationcacheNetworkStateUpdatedClient implements ApplicationCacheNetworkStateUpdatedClient.
type applicationcacheNetworkStateUpdatedClient struct{ rpcc.Stream }

func (c *applicationcacheNetworkStateUpdatedClient) Recv() (*cdpevent.ApplicationCacheNetworkStateUpdatedReply, error) {
	event := new(cdpevent.ApplicationCacheNetworkStateUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "ApplicationCache", Op: "NetworkStateUpdated Recv", Err: err}
	}
	return event, nil
}

// The CSS domain. This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles) have an associated id used in subsequent operations on the related object. Each object type has a specific id structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the get*ForNode() calls (which accept a DOM node id). A client can also discover all the existing stylesheets with the getAllStyleSheets() method (or keeping track of the styleSheetAdded/styleSheetRemoved events) and subsequently load the required stylesheet contents using the getStyleSheet[Text]() methods.
type CSS interface {
	// Command Enable
	//
	// Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables the CSS agent for the given page.
	Disable(context.Context) error

	// Command GetMatchedStylesForNode
	//
	// Returns requested styles for a DOM node identified by nodeId.
	GetMatchedStylesForNode(context.Context, *cdpcmd.CSSGetMatchedStylesForNodeArgs) (*cdpcmd.CSSGetMatchedStylesForNodeReply, error)

	// Command GetInlineStylesForNode
	//
	// Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM attributes) for a DOM node identified by nodeId.
	GetInlineStylesForNode(context.Context, *cdpcmd.CSSGetInlineStylesForNodeArgs) (*cdpcmd.CSSGetInlineStylesForNodeReply, error)

	// Command GetComputedStyleForNode
	//
	// Returns the computed style for a DOM node identified by nodeId.
	GetComputedStyleForNode(context.Context, *cdpcmd.CSSGetComputedStyleForNodeArgs) (*cdpcmd.CSSGetComputedStyleForNodeReply, error)

	// Command GetPlatformFontsForNode
	//
	// Requests information about platform fonts which we used to render child TextNodes in the given node.
	GetPlatformFontsForNode(context.Context, *cdpcmd.CSSGetPlatformFontsForNodeArgs) (*cdpcmd.CSSGetPlatformFontsForNodeReply, error)

	// Command GetStyleSheetText
	//
	// Returns the current textual content and the URL for a stylesheet.
	GetStyleSheetText(context.Context, *cdpcmd.CSSGetStyleSheetTextArgs) (*cdpcmd.CSSGetStyleSheetTextReply, error)

	// Command CollectClassNames
	//
	// Returns all class names from specified stylesheet.
	CollectClassNames(context.Context, *cdpcmd.CSSCollectClassNamesArgs) (*cdpcmd.CSSCollectClassNamesReply, error)

	// Command SetStyleSheetText
	//
	// Sets the new stylesheet text.
	SetStyleSheetText(context.Context, *cdpcmd.CSSSetStyleSheetTextArgs) (*cdpcmd.CSSSetStyleSheetTextReply, error)

	// Command SetRuleSelector
	//
	// Modifies the rule selector.
	SetRuleSelector(context.Context, *cdpcmd.CSSSetRuleSelectorArgs) (*cdpcmd.CSSSetRuleSelectorReply, error)

	// Command SetKeyframeKey
	//
	// Modifies the keyframe rule key text.
	SetKeyframeKey(context.Context, *cdpcmd.CSSSetKeyframeKeyArgs) (*cdpcmd.CSSSetKeyframeKeyReply, error)

	// Command SetStyleTexts
	//
	// Applies specified style edits one after another in the given order.
	SetStyleTexts(context.Context, *cdpcmd.CSSSetStyleTextsArgs) (*cdpcmd.CSSSetStyleTextsReply, error)

	// Command SetMediaText
	//
	// Modifies the rule selector.
	SetMediaText(context.Context, *cdpcmd.CSSSetMediaTextArgs) (*cdpcmd.CSSSetMediaTextReply, error)

	// Command CreateStyleSheet
	//
	// Creates a new special "via-inspector" stylesheet in the frame with given frameId.
	CreateStyleSheet(context.Context, *cdpcmd.CSSCreateStyleSheetArgs) (*cdpcmd.CSSCreateStyleSheetReply, error)

	// Command AddRule
	//
	// Inserts a new rule with the given ruleText in a stylesheet with given styleSheetId, at the position specified by location.
	AddRule(context.Context, *cdpcmd.CSSAddRuleArgs) (*cdpcmd.CSSAddRuleReply, error)

	// Command ForcePseudoState
	//
	// Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser.
	ForcePseudoState(context.Context, *cdpcmd.CSSForcePseudoStateArgs) error

	// Command GetMediaQueries
	//
	// Returns all media queries parsed by the rendering engine.
	GetMediaQueries(context.Context) (*cdpcmd.CSSGetMediaQueriesReply, error)

	// Command SetEffectivePropertyValueForNode
	//
	// Find a rule with the given active property for the given node and set the new value for this property
	SetEffectivePropertyValueForNode(context.Context, *cdpcmd.CSSSetEffectivePropertyValueForNodeArgs) error

	// Command GetBackgroundColors
	//
	//
	GetBackgroundColors(context.Context, *cdpcmd.CSSGetBackgroundColorsArgs) (*cdpcmd.CSSGetBackgroundColorsReply, error)

	// Command GetLayoutTreeAndStyles
	//
	// For the main document and any content documents, return the LayoutTreeNodes and a whitelisted subset of the computed style. It only returns pushed nodes, on way to pull all nodes is to call DOM.getDocument with a depth of -1.
	GetLayoutTreeAndStyles(context.Context, *cdpcmd.CSSGetLayoutTreeAndStylesArgs) (*cdpcmd.CSSGetLayoutTreeAndStylesReply, error)

	// Command StartRuleUsageTracking
	//
	// Enables the selector recording.
	StartRuleUsageTracking(context.Context) error

	// Command StopRuleUsageTracking
	//
	// The list of rules with an indication of whether these were used
	StopRuleUsageTracking(context.Context) (*cdpcmd.CSSStopRuleUsageTrackingReply, error)

	// Event MediaQueryResultChanged
	//
	// Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features.
	MediaQueryResultChanged(context.Context) (cdpevent.CSSMediaQueryResultChangedClient, error)

	// Event FontsUpdated
	//
	// Fires whenever a web font gets loaded.
	FontsUpdated(context.Context) (cdpevent.CSSFontsUpdatedClient, error)

	// Event StyleSheetChanged
	//
	// Fired whenever a stylesheet is changed as a result of the client operation.
	StyleSheetChanged(context.Context) (cdpevent.CSSStyleSheetChangedClient, error)

	// Event StyleSheetAdded
	//
	// Fired whenever an active document stylesheet is added.
	StyleSheetAdded(context.Context) (cdpevent.CSSStyleSheetAddedClient, error)

	// Event StyleSheetRemoved
	//
	// Fired whenever an active document stylesheet is removed.
	StyleSheetRemoved(context.Context) (cdpevent.CSSStyleSheetRemovedClient, error)
}

// cssDomain implements the CSS domain.
type cssDomain struct{ conn *rpcc.Conn }

func (d *cssDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.CSSEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "Enable", Err: err}
	}
	return
}

func (d *cssDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.CSSDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "Disable", Err: err}
	}
	return
}

func (d *cssDomain) GetMatchedStylesForNode(ctx context.Context, args *cdpcmd.CSSGetMatchedStylesForNodeArgs) (reply *cdpcmd.CSSGetMatchedStylesForNodeReply, err error) {
	reply = new(cdpcmd.CSSGetMatchedStylesForNodeReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSGetMatchedStylesForNode.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "GetMatchedStylesForNode", Err: err}
	}
	return
}

// NewCSSGetMatchedStylesForNodeArgs initializes the arguments for GetMatchedStylesForNode.
func NewCSSGetMatchedStylesForNodeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.CSSGetMatchedStylesForNodeArgs {
	args := new(cdpcmd.CSSGetMatchedStylesForNodeArgs)
	args.NodeID = nodeID
	return args
}

func (d *cssDomain) GetInlineStylesForNode(ctx context.Context, args *cdpcmd.CSSGetInlineStylesForNodeArgs) (reply *cdpcmd.CSSGetInlineStylesForNodeReply, err error) {
	reply = new(cdpcmd.CSSGetInlineStylesForNodeReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSGetInlineStylesForNode.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "GetInlineStylesForNode", Err: err}
	}
	return
}

// NewCSSGetInlineStylesForNodeArgs initializes the arguments for GetInlineStylesForNode.
func NewCSSGetInlineStylesForNodeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.CSSGetInlineStylesForNodeArgs {
	args := new(cdpcmd.CSSGetInlineStylesForNodeArgs)
	args.NodeID = nodeID
	return args
}

func (d *cssDomain) GetComputedStyleForNode(ctx context.Context, args *cdpcmd.CSSGetComputedStyleForNodeArgs) (reply *cdpcmd.CSSGetComputedStyleForNodeReply, err error) {
	reply = new(cdpcmd.CSSGetComputedStyleForNodeReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSGetComputedStyleForNode.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "GetComputedStyleForNode", Err: err}
	}
	return
}

// NewCSSGetComputedStyleForNodeArgs initializes the arguments for GetComputedStyleForNode.
func NewCSSGetComputedStyleForNodeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.CSSGetComputedStyleForNodeArgs {
	args := new(cdpcmd.CSSGetComputedStyleForNodeArgs)
	args.NodeID = nodeID
	return args
}

func (d *cssDomain) GetPlatformFontsForNode(ctx context.Context, args *cdpcmd.CSSGetPlatformFontsForNodeArgs) (reply *cdpcmd.CSSGetPlatformFontsForNodeReply, err error) {
	reply = new(cdpcmd.CSSGetPlatformFontsForNodeReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSGetPlatformFontsForNode.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "GetPlatformFontsForNode", Err: err}
	}
	return
}

// NewCSSGetPlatformFontsForNodeArgs initializes the arguments for GetPlatformFontsForNode.
func NewCSSGetPlatformFontsForNodeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.CSSGetPlatformFontsForNodeArgs {
	args := new(cdpcmd.CSSGetPlatformFontsForNodeArgs)
	args.NodeID = nodeID
	return args
}

func (d *cssDomain) GetStyleSheetText(ctx context.Context, args *cdpcmd.CSSGetStyleSheetTextArgs) (reply *cdpcmd.CSSGetStyleSheetTextReply, err error) {
	reply = new(cdpcmd.CSSGetStyleSheetTextReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSGetStyleSheetText.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "GetStyleSheetText", Err: err}
	}
	return
}

// NewCSSGetStyleSheetTextArgs initializes the arguments for GetStyleSheetText.
func NewCSSGetStyleSheetTextArgs(styleSheetID cdptype.CSSStyleSheetID) *cdpcmd.CSSGetStyleSheetTextArgs {
	args := new(cdpcmd.CSSGetStyleSheetTextArgs)
	args.StyleSheetID = styleSheetID
	return args
}

func (d *cssDomain) CollectClassNames(ctx context.Context, args *cdpcmd.CSSCollectClassNamesArgs) (reply *cdpcmd.CSSCollectClassNamesReply, err error) {
	reply = new(cdpcmd.CSSCollectClassNamesReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSCollectClassNames.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "CollectClassNames", Err: err}
	}
	return
}

// NewCSSCollectClassNamesArgs initializes the arguments for CollectClassNames.
func NewCSSCollectClassNamesArgs(styleSheetID cdptype.CSSStyleSheetID) *cdpcmd.CSSCollectClassNamesArgs {
	args := new(cdpcmd.CSSCollectClassNamesArgs)
	args.StyleSheetID = styleSheetID
	return args
}

func (d *cssDomain) SetStyleSheetText(ctx context.Context, args *cdpcmd.CSSSetStyleSheetTextArgs) (reply *cdpcmd.CSSSetStyleSheetTextReply, err error) {
	reply = new(cdpcmd.CSSSetStyleSheetTextReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSSetStyleSheetText.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "SetStyleSheetText", Err: err}
	}
	return
}

// NewCSSSetStyleSheetTextArgs initializes the arguments for SetStyleSheetText.
func NewCSSSetStyleSheetTextArgs(styleSheetID cdptype.CSSStyleSheetID, text string) *cdpcmd.CSSSetStyleSheetTextArgs {
	args := new(cdpcmd.CSSSetStyleSheetTextArgs)
	args.StyleSheetID = styleSheetID
	args.Text = text
	return args
}

func (d *cssDomain) SetRuleSelector(ctx context.Context, args *cdpcmd.CSSSetRuleSelectorArgs) (reply *cdpcmd.CSSSetRuleSelectorReply, err error) {
	reply = new(cdpcmd.CSSSetRuleSelectorReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSSetRuleSelector.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "SetRuleSelector", Err: err}
	}
	return
}

// NewCSSSetRuleSelectorArgs initializes the arguments for SetRuleSelector.
func NewCSSSetRuleSelectorArgs(styleSheetID cdptype.CSSStyleSheetID, rang cdptype.CSSSourceRange, selector string) *cdpcmd.CSSSetRuleSelectorArgs {
	args := new(cdpcmd.CSSSetRuleSelectorArgs)
	args.StyleSheetID = styleSheetID
	args.Range = rang
	args.Selector = selector
	return args
}

func (d *cssDomain) SetKeyframeKey(ctx context.Context, args *cdpcmd.CSSSetKeyframeKeyArgs) (reply *cdpcmd.CSSSetKeyframeKeyReply, err error) {
	reply = new(cdpcmd.CSSSetKeyframeKeyReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSSetKeyframeKey.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "SetKeyframeKey", Err: err}
	}
	return
}

// NewCSSSetKeyframeKeyArgs initializes the arguments for SetKeyframeKey.
func NewCSSSetKeyframeKeyArgs(styleSheetID cdptype.CSSStyleSheetID, rang cdptype.CSSSourceRange, keyText string) *cdpcmd.CSSSetKeyframeKeyArgs {
	args := new(cdpcmd.CSSSetKeyframeKeyArgs)
	args.StyleSheetID = styleSheetID
	args.Range = rang
	args.KeyText = keyText
	return args
}

func (d *cssDomain) SetStyleTexts(ctx context.Context, args *cdpcmd.CSSSetStyleTextsArgs) (reply *cdpcmd.CSSSetStyleTextsReply, err error) {
	reply = new(cdpcmd.CSSSetStyleTextsReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSSetStyleTexts.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "SetStyleTexts", Err: err}
	}
	return
}

// NewCSSSetStyleTextsArgs initializes the arguments for SetStyleTexts.
func NewCSSSetStyleTextsArgs(edits []cdptype.CSSStyleDeclarationEdit) *cdpcmd.CSSSetStyleTextsArgs {
	args := new(cdpcmd.CSSSetStyleTextsArgs)
	args.Edits = edits
	return args
}

func (d *cssDomain) SetMediaText(ctx context.Context, args *cdpcmd.CSSSetMediaTextArgs) (reply *cdpcmd.CSSSetMediaTextReply, err error) {
	reply = new(cdpcmd.CSSSetMediaTextReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSSetMediaText.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "SetMediaText", Err: err}
	}
	return
}

// NewCSSSetMediaTextArgs initializes the arguments for SetMediaText.
func NewCSSSetMediaTextArgs(styleSheetID cdptype.CSSStyleSheetID, rang cdptype.CSSSourceRange, text string) *cdpcmd.CSSSetMediaTextArgs {
	args := new(cdpcmd.CSSSetMediaTextArgs)
	args.StyleSheetID = styleSheetID
	args.Range = rang
	args.Text = text
	return args
}

func (d *cssDomain) CreateStyleSheet(ctx context.Context, args *cdpcmd.CSSCreateStyleSheetArgs) (reply *cdpcmd.CSSCreateStyleSheetReply, err error) {
	reply = new(cdpcmd.CSSCreateStyleSheetReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSCreateStyleSheet.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "CreateStyleSheet", Err: err}
	}
	return
}

// NewCSSCreateStyleSheetArgs initializes the arguments for CreateStyleSheet.
func NewCSSCreateStyleSheetArgs(frameID cdptype.PageFrameID) *cdpcmd.CSSCreateStyleSheetArgs {
	args := new(cdpcmd.CSSCreateStyleSheetArgs)
	args.FrameID = frameID
	return args
}

func (d *cssDomain) AddRule(ctx context.Context, args *cdpcmd.CSSAddRuleArgs) (reply *cdpcmd.CSSAddRuleReply, err error) {
	reply = new(cdpcmd.CSSAddRuleReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSAddRule.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "AddRule", Err: err}
	}
	return
}

// NewCSSAddRuleArgs initializes the arguments for AddRule.
func NewCSSAddRuleArgs(styleSheetID cdptype.CSSStyleSheetID, ruleText string, location cdptype.CSSSourceRange) *cdpcmd.CSSAddRuleArgs {
	args := new(cdpcmd.CSSAddRuleArgs)
	args.StyleSheetID = styleSheetID
	args.RuleText = ruleText
	args.Location = location
	return args
}

func (d *cssDomain) ForcePseudoState(ctx context.Context, args *cdpcmd.CSSForcePseudoStateArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.CSSForcePseudoState.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "ForcePseudoState", Err: err}
	}
	return
}

// NewCSSForcePseudoStateArgs initializes the arguments for ForcePseudoState.
func NewCSSForcePseudoStateArgs(nodeID cdptype.DOMNodeID, forcedPseudoClasses []string) *cdpcmd.CSSForcePseudoStateArgs {
	args := new(cdpcmd.CSSForcePseudoStateArgs)
	args.NodeID = nodeID
	args.ForcedPseudoClasses = forcedPseudoClasses
	return args
}

func (d *cssDomain) GetMediaQueries(ctx context.Context) (reply *cdpcmd.CSSGetMediaQueriesReply, err error) {
	reply = new(cdpcmd.CSSGetMediaQueriesReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSGetMediaQueries.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "GetMediaQueries", Err: err}
	}
	return
}

func (d *cssDomain) SetEffectivePropertyValueForNode(ctx context.Context, args *cdpcmd.CSSSetEffectivePropertyValueForNodeArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.CSSSetEffectivePropertyValueForNode.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "SetEffectivePropertyValueForNode", Err: err}
	}
	return
}

// NewCSSSetEffectivePropertyValueForNodeArgs initializes the arguments for SetEffectivePropertyValueForNode.
func NewCSSSetEffectivePropertyValueForNodeArgs(nodeID cdptype.DOMNodeID, propertyName string, value string) *cdpcmd.CSSSetEffectivePropertyValueForNodeArgs {
	args := new(cdpcmd.CSSSetEffectivePropertyValueForNodeArgs)
	args.NodeID = nodeID
	args.PropertyName = propertyName
	args.Value = value
	return args
}

func (d *cssDomain) GetBackgroundColors(ctx context.Context, args *cdpcmd.CSSGetBackgroundColorsArgs) (reply *cdpcmd.CSSGetBackgroundColorsReply, err error) {
	reply = new(cdpcmd.CSSGetBackgroundColorsReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSGetBackgroundColors.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "GetBackgroundColors", Err: err}
	}
	return
}

// NewCSSGetBackgroundColorsArgs initializes the arguments for GetBackgroundColors.
func NewCSSGetBackgroundColorsArgs(nodeID cdptype.DOMNodeID) *cdpcmd.CSSGetBackgroundColorsArgs {
	args := new(cdpcmd.CSSGetBackgroundColorsArgs)
	args.NodeID = nodeID
	return args
}

func (d *cssDomain) GetLayoutTreeAndStyles(ctx context.Context, args *cdpcmd.CSSGetLayoutTreeAndStylesArgs) (reply *cdpcmd.CSSGetLayoutTreeAndStylesReply, err error) {
	reply = new(cdpcmd.CSSGetLayoutTreeAndStylesReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSGetLayoutTreeAndStyles.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "GetLayoutTreeAndStyles", Err: err}
	}
	return
}

// NewCSSGetLayoutTreeAndStylesArgs initializes the arguments for GetLayoutTreeAndStyles.
func NewCSSGetLayoutTreeAndStylesArgs(computedStyleWhitelist []string) *cdpcmd.CSSGetLayoutTreeAndStylesArgs {
	args := new(cdpcmd.CSSGetLayoutTreeAndStylesArgs)
	args.ComputedStyleWhitelist = computedStyleWhitelist
	return args
}

func (d *cssDomain) StartRuleUsageTracking(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.CSSStartRuleUsageTracking.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "StartRuleUsageTracking", Err: err}
	}
	return
}

func (d *cssDomain) StopRuleUsageTracking(ctx context.Context) (reply *cdpcmd.CSSStopRuleUsageTrackingReply, err error) {
	reply = new(cdpcmd.CSSStopRuleUsageTrackingReply)

	err = rpcc.Invoke(ctx, cdpcmd.CSSStopRuleUsageTracking.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CSS", Op: "StopRuleUsageTracking", Err: err}
	}
	return
}

func (d *cssDomain) MediaQueryResultChanged(ctx context.Context) (cdpevent.CSSMediaQueryResultChangedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSMediaQueryResultChanged.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &cssMediaQueryResultChangedClient{Stream: s}, nil
}

// cssMediaQueryResultChangedClient implements CSSMediaQueryResultChangedClient.
type cssMediaQueryResultChangedClient struct{ rpcc.Stream }

func (c *cssMediaQueryResultChangedClient) Recv() (*cdpevent.CSSMediaQueryResultChangedReply, error) {
	event := new(cdpevent.CSSMediaQueryResultChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "CSS", Op: "MediaQueryResultChanged Recv", Err: err}
	}
	return event, nil
}

func (d *cssDomain) FontsUpdated(ctx context.Context) (cdpevent.CSSFontsUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSFontsUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &cssFontsUpdatedClient{Stream: s}, nil
}

// cssFontsUpdatedClient implements CSSFontsUpdatedClient.
type cssFontsUpdatedClient struct{ rpcc.Stream }

func (c *cssFontsUpdatedClient) Recv() (*cdpevent.CSSFontsUpdatedReply, error) {
	event := new(cdpevent.CSSFontsUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "CSS", Op: "FontsUpdated Recv", Err: err}
	}
	return event, nil
}

func (d *cssDomain) StyleSheetChanged(ctx context.Context) (cdpevent.CSSStyleSheetChangedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSStyleSheetChanged.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &cssStyleSheetChangedClient{Stream: s}, nil
}

// cssStyleSheetChangedClient implements CSSStyleSheetChangedClient.
type cssStyleSheetChangedClient struct{ rpcc.Stream }

func (c *cssStyleSheetChangedClient) Recv() (*cdpevent.CSSStyleSheetChangedReply, error) {
	event := new(cdpevent.CSSStyleSheetChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "CSS", Op: "StyleSheetChanged Recv", Err: err}
	}
	return event, nil
}

func (d *cssDomain) StyleSheetAdded(ctx context.Context) (cdpevent.CSSStyleSheetAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSStyleSheetAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &cssStyleSheetAddedClient{Stream: s}, nil
}

// cssStyleSheetAddedClient implements CSSStyleSheetAddedClient.
type cssStyleSheetAddedClient struct{ rpcc.Stream }

func (c *cssStyleSheetAddedClient) Recv() (*cdpevent.CSSStyleSheetAddedReply, error) {
	event := new(cdpevent.CSSStyleSheetAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "CSS", Op: "StyleSheetAdded Recv", Err: err}
	}
	return event, nil
}

func (d *cssDomain) StyleSheetRemoved(ctx context.Context) (cdpevent.CSSStyleSheetRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSStyleSheetRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &cssStyleSheetRemovedClient{Stream: s}, nil
}

// cssStyleSheetRemovedClient implements CSSStyleSheetRemovedClient.
type cssStyleSheetRemovedClient struct{ rpcc.Stream }

func (c *cssStyleSheetRemovedClient) Recv() (*cdpevent.CSSStyleSheetRemovedReply, error) {
	event := new(cdpevent.CSSStyleSheetRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "CSS", Op: "StyleSheetRemoved Recv", Err: err}
	}
	return event, nil
}

// The CacheStorage domain.
type CacheStorage interface {
	// Command RequestCacheNames
	//
	// Requests cache names.
	RequestCacheNames(context.Context, *cdpcmd.CacheStorageRequestCacheNamesArgs) (*cdpcmd.CacheStorageRequestCacheNamesReply, error)

	// Command RequestEntries
	//
	// Requests data from cache.
	RequestEntries(context.Context, *cdpcmd.CacheStorageRequestEntriesArgs) (*cdpcmd.CacheStorageRequestEntriesReply, error)

	// Command DeleteCache
	//
	// Deletes a cache.
	DeleteCache(context.Context, *cdpcmd.CacheStorageDeleteCacheArgs) error

	// Command DeleteEntry
	//
	// Deletes a cache entry.
	DeleteEntry(context.Context, *cdpcmd.CacheStorageDeleteEntryArgs) error
}

// cachestorageDomain implements the CacheStorage domain.
type cachestorageDomain struct{ conn *rpcc.Conn }

func (d *cachestorageDomain) RequestCacheNames(ctx context.Context, args *cdpcmd.CacheStorageRequestCacheNamesArgs) (reply *cdpcmd.CacheStorageRequestCacheNamesReply, err error) {
	reply = new(cdpcmd.CacheStorageRequestCacheNamesReply)

	err = rpcc.Invoke(ctx, cdpcmd.CacheStorageRequestCacheNames.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CacheStorage", Op: "RequestCacheNames", Err: err}
	}
	return
}

// NewCacheStorageRequestCacheNamesArgs initializes the arguments for RequestCacheNames.
func NewCacheStorageRequestCacheNamesArgs(securityOrigin string) *cdpcmd.CacheStorageRequestCacheNamesArgs {
	args := new(cdpcmd.CacheStorageRequestCacheNamesArgs)
	args.SecurityOrigin = securityOrigin
	return args
}

func (d *cachestorageDomain) RequestEntries(ctx context.Context, args *cdpcmd.CacheStorageRequestEntriesArgs) (reply *cdpcmd.CacheStorageRequestEntriesReply, err error) {
	reply = new(cdpcmd.CacheStorageRequestEntriesReply)

	err = rpcc.Invoke(ctx, cdpcmd.CacheStorageRequestEntries.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "CacheStorage", Op: "RequestEntries", Err: err}
	}
	return
}

// NewCacheStorageRequestEntriesArgs initializes the arguments for RequestEntries.
func NewCacheStorageRequestEntriesArgs(cacheID cdptype.CacheStorageCacheID, skipCount int, pageSize int) *cdpcmd.CacheStorageRequestEntriesArgs {
	args := new(cdpcmd.CacheStorageRequestEntriesArgs)
	args.CacheID = cacheID
	args.SkipCount = skipCount
	args.PageSize = pageSize
	return args
}

func (d *cachestorageDomain) DeleteCache(ctx context.Context, args *cdpcmd.CacheStorageDeleteCacheArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.CacheStorageDeleteCache.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "CacheStorage", Op: "DeleteCache", Err: err}
	}
	return
}

// NewCacheStorageDeleteCacheArgs initializes the arguments for DeleteCache.
func NewCacheStorageDeleteCacheArgs(cacheID cdptype.CacheStorageCacheID) *cdpcmd.CacheStorageDeleteCacheArgs {
	args := new(cdpcmd.CacheStorageDeleteCacheArgs)
	args.CacheID = cacheID
	return args
}

func (d *cachestorageDomain) DeleteEntry(ctx context.Context, args *cdpcmd.CacheStorageDeleteEntryArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.CacheStorageDeleteEntry.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "CacheStorage", Op: "DeleteEntry", Err: err}
	}
	return
}

// NewCacheStorageDeleteEntryArgs initializes the arguments for DeleteEntry.
func NewCacheStorageDeleteEntryArgs(cacheID cdptype.CacheStorageCacheID, request string) *cdpcmd.CacheStorageDeleteEntryArgs {
	args := new(cdpcmd.CacheStorageDeleteEntryArgs)
	args.CacheID = cacheID
	args.Request = request
	return args
}

// The Console domain. This domain is deprecated - use Runtime or Log instead.
type Console interface {
	// Command Enable
	//
	// Enables console domain, sends the messages collected so far to the client by means of the messageAdded notification.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables console domain, prevents further console messages from being reported to the client.
	Disable(context.Context) error

	// Command ClearMessages
	//
	// Does nothing.
	ClearMessages(context.Context) error

	// Event MessageAdded
	//
	// Issued when new console message is added.
	MessageAdded(context.Context) (cdpevent.ConsoleMessageAddedClient, error)
}

// consoleDomain implements the Console domain.
type consoleDomain struct{ conn *rpcc.Conn }

func (d *consoleDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ConsoleEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Console", Op: "Enable", Err: err}
	}
	return
}

func (d *consoleDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ConsoleDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Console", Op: "Disable", Err: err}
	}
	return
}

func (d *consoleDomain) ClearMessages(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ConsoleClearMessages.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Console", Op: "ClearMessages", Err: err}
	}
	return
}

func (d *consoleDomain) MessageAdded(ctx context.Context) (cdpevent.ConsoleMessageAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ConsoleMessageAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &consoleMessageAddedClient{Stream: s}, nil
}

// consoleMessageAddedClient implements ConsoleMessageAddedClient.
type consoleMessageAddedClient struct{ rpcc.Stream }

func (c *consoleMessageAddedClient) Recv() (*cdpevent.ConsoleMessageAddedReply, error) {
	event := new(cdpevent.ConsoleMessageAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Console", Op: "MessageAdded Recv", Err: err}
	}
	return event, nil
}

// The DOM domain. This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an id. This id can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client's responsibility to collect information about the nodes that were sent to the client.
//
// Note that iframe owner elements will return corresponding document elements as their child nodes.
type DOM interface {
	// Command Enable
	//
	// Enables DOM agent for the given page.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables DOM agent for the given page.
	Disable(context.Context) error

	// Command GetDocument
	//
	// Returns the root DOM node (and optionally the subtree) to the caller.
	GetDocument(context.Context, *cdpcmd.DOMGetDocumentArgs) (*cdpcmd.DOMGetDocumentReply, error)

	// Command GetFlattenedDocument
	//
	// Returns the root DOM node (and optionally the subtree) to the caller.
	GetFlattenedDocument(context.Context, *cdpcmd.DOMGetFlattenedDocumentArgs) (*cdpcmd.DOMGetFlattenedDocumentReply, error)

	// Command CollectClassNamesFromSubtree
	//
	// Collects class names for the node with given id and all of it's child nodes.
	CollectClassNamesFromSubtree(context.Context, *cdpcmd.DOMCollectClassNamesFromSubtreeArgs) (*cdpcmd.DOMCollectClassNamesFromSubtreeReply, error)

	// Command RequestChildNodes
	//
	// Requests that children of the node with given id are returned to the caller in form of setChildNodes events where not only immediate children are retrieved, but all children down to the specified depth.
	RequestChildNodes(context.Context, *cdpcmd.DOMRequestChildNodesArgs) error

	// Command QuerySelector
	//
	// Executes querySelector on a given node.
	QuerySelector(context.Context, *cdpcmd.DOMQuerySelectorArgs) (*cdpcmd.DOMQuerySelectorReply, error)

	// Command QuerySelectorAll
	//
	// Executes querySelectorAll on a given node.
	QuerySelectorAll(context.Context, *cdpcmd.DOMQuerySelectorAllArgs) (*cdpcmd.DOMQuerySelectorAllReply, error)

	// Command SetNodeName
	//
	// Sets node name for a node with given id.
	SetNodeName(context.Context, *cdpcmd.DOMSetNodeNameArgs) (*cdpcmd.DOMSetNodeNameReply, error)

	// Command SetNodeValue
	//
	// Sets node value for a node with given id.
	SetNodeValue(context.Context, *cdpcmd.DOMSetNodeValueArgs) error

	// Command RemoveNode
	//
	// Removes node with given id.
	RemoveNode(context.Context, *cdpcmd.DOMRemoveNodeArgs) error

	// Command SetAttributeValue
	//
	// Sets attribute for an element with given id.
	SetAttributeValue(context.Context, *cdpcmd.DOMSetAttributeValueArgs) error

	// Command SetAttributesAsText
	//
	// Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs.
	SetAttributesAsText(context.Context, *cdpcmd.DOMSetAttributesAsTextArgs) error

	// Command RemoveAttribute
	//
	// Removes attribute with given name from an element with given id.
	RemoveAttribute(context.Context, *cdpcmd.DOMRemoveAttributeArgs) error

	// Command GetOuterHTML
	//
	// Returns node's HTML markup.
	GetOuterHTML(context.Context, *cdpcmd.DOMGetOuterHTMLArgs) (*cdpcmd.DOMGetOuterHTMLReply, error)

	// Command SetOuterHTML
	//
	// Sets node HTML markup, returns new node id.
	SetOuterHTML(context.Context, *cdpcmd.DOMSetOuterHTMLArgs) error

	// Command PerformSearch
	//
	// Searches for a given string in the DOM tree. Use getSearchResults to access search results or cancelSearch to end this search session.
	PerformSearch(context.Context, *cdpcmd.DOMPerformSearchArgs) (*cdpcmd.DOMPerformSearchReply, error)

	// Command GetSearchResults
	//
	// Returns search results from given fromIndex to given toIndex from the sarch with the given identifier.
	GetSearchResults(context.Context, *cdpcmd.DOMGetSearchResultsArgs) (*cdpcmd.DOMGetSearchResultsReply, error)

	// Command DiscardSearchResults
	//
	// Discards search results from the session with the given id. getSearchResults should no longer be called for that search.
	DiscardSearchResults(context.Context, *cdpcmd.DOMDiscardSearchResultsArgs) error

	// Command RequestNode
	//
	// Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of setChildNodes notifications.
	RequestNode(context.Context, *cdpcmd.DOMRequestNodeArgs) (*cdpcmd.DOMRequestNodeReply, error)

	// Command SetInspectMode
	//
	// Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection.
	SetInspectMode(context.Context, *cdpcmd.DOMSetInspectModeArgs) error

	// Command HighlightRect
	//
	// Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
	HighlightRect(context.Context, *cdpcmd.DOMHighlightRectArgs) error

	// Command HighlightQuad
	//
	// Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
	HighlightQuad(context.Context, *cdpcmd.DOMHighlightQuadArgs) error

	// Command HighlightNode
	//
	// Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified.
	HighlightNode(context.Context, *cdpcmd.DOMHighlightNodeArgs) error

	// Command HideHighlight
	//
	// Hides DOM node highlight.
	HideHighlight(context.Context) error

	// Command HighlightFrame
	//
	// Highlights owner element of the frame with given id.
	HighlightFrame(context.Context, *cdpcmd.DOMHighlightFrameArgs) error

	// Command PushNodeByPathToFrontend
	//
	// Requests that the node is sent to the caller given its path. // FIXME, use XPath
	PushNodeByPathToFrontend(context.Context, *cdpcmd.DOMPushNodeByPathToFrontendArgs) (*cdpcmd.DOMPushNodeByPathToFrontendReply, error)

	// Command PushNodesByBackendIdsToFrontend
	//
	// Requests that a batch of nodes is sent to the caller given their backend node ids.
	PushNodesByBackendIdsToFrontend(context.Context, *cdpcmd.DOMPushNodesByBackendIdsToFrontendArgs) (*cdpcmd.DOMPushNodesByBackendIdsToFrontendReply, error)

	// Command SetInspectedNode
	//
	// Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
	SetInspectedNode(context.Context, *cdpcmd.DOMSetInspectedNodeArgs) error

	// Command ResolveNode
	//
	// Resolves JavaScript node object for given node id.
	ResolveNode(context.Context, *cdpcmd.DOMResolveNodeArgs) (*cdpcmd.DOMResolveNodeReply, error)

	// Command GetAttributes
	//
	// Returns attributes for the specified node.
	GetAttributes(context.Context, *cdpcmd.DOMGetAttributesArgs) (*cdpcmd.DOMGetAttributesReply, error)

	// Command CopyTo
	//
	// Creates a deep copy of the specified node and places it into the target container before the given anchor.
	CopyTo(context.Context, *cdpcmd.DOMCopyToArgs) (*cdpcmd.DOMCopyToReply, error)

	// Command MoveTo
	//
	// Moves node into the new container, places it before the given anchor.
	MoveTo(context.Context, *cdpcmd.DOMMoveToArgs) (*cdpcmd.DOMMoveToReply, error)

	// Command Undo
	//
	// Undoes the last performed action.
	Undo(context.Context) error

	// Command Redo
	//
	// Re-does the last undone action.
	Redo(context.Context) error

	// Command MarkUndoableState
	//
	// Marks last undoable state.
	MarkUndoableState(context.Context) error

	// Command Focus
	//
	// Focuses the given element.
	Focus(context.Context, *cdpcmd.DOMFocusArgs) error

	// Command SetFileInputFiles
	//
	// Sets files for the given file input element.
	SetFileInputFiles(context.Context, *cdpcmd.DOMSetFileInputFilesArgs) error

	// Command GetBoxModel
	//
	// Returns boxes for the currently selected nodes.
	GetBoxModel(context.Context, *cdpcmd.DOMGetBoxModelArgs) (*cdpcmd.DOMGetBoxModelReply, error)

	// Command GetNodeForLocation
	//
	// Returns node id at given location.
	GetNodeForLocation(context.Context, *cdpcmd.DOMGetNodeForLocationArgs) (*cdpcmd.DOMGetNodeForLocationReply, error)

	// Command GetRelayoutBoundary
	//
	// Returns the id of the nearest ancestor that is a relayout boundary.
	GetRelayoutBoundary(context.Context, *cdpcmd.DOMGetRelayoutBoundaryArgs) (*cdpcmd.DOMGetRelayoutBoundaryReply, error)

	// Command GetHighlightObjectForTest
	//
	// For testing.
	GetHighlightObjectForTest(context.Context, *cdpcmd.DOMGetHighlightObjectForTestArgs) (*cdpcmd.DOMGetHighlightObjectForTestReply, error)

	// Event DocumentUpdated
	//
	// Fired when Document has been totally updated. Node ids are no longer valid.
	DocumentUpdated(context.Context) (cdpevent.DOMDocumentUpdatedClient, error)

	// Event InspectNodeRequested
	//
	// Fired when the node should be inspected. This happens after call to setInspectMode.
	InspectNodeRequested(context.Context) (cdpevent.DOMInspectNodeRequestedClient, error)

	// Event SetChildNodes
	//
	// Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids.
	SetChildNodes(context.Context) (cdpevent.DOMSetChildNodesClient, error)

	// Event AttributeModified
	//
	// Fired when Element's attribute is modified.
	AttributeModified(context.Context) (cdpevent.DOMAttributeModifiedClient, error)

	// Event AttributeRemoved
	//
	// Fired when Element's attribute is removed.
	AttributeRemoved(context.Context) (cdpevent.DOMAttributeRemovedClient, error)

	// Event InlineStyleInvalidated
	//
	// Fired when Element's inline style is modified via a CSS property modification.
	InlineStyleInvalidated(context.Context) (cdpevent.DOMInlineStyleInvalidatedClient, error)

	// Event CharacterDataModified
	//
	// Mirrors DOMCharacterDataModified event.
	CharacterDataModified(context.Context) (cdpevent.DOMCharacterDataModifiedClient, error)

	// Event ChildNodeCountUpdated
	//
	// Fired when Container's child node count has changed.
	ChildNodeCountUpdated(context.Context) (cdpevent.DOMChildNodeCountUpdatedClient, error)

	// Event ChildNodeInserted
	//
	// Mirrors DOMNodeInserted event.
	ChildNodeInserted(context.Context) (cdpevent.DOMChildNodeInsertedClient, error)

	// Event ChildNodeRemoved
	//
	// Mirrors DOMNodeRemoved event.
	ChildNodeRemoved(context.Context) (cdpevent.DOMChildNodeRemovedClient, error)

	// Event ShadowRootPushed
	//
	// Called when shadow root is pushed into the element.
	ShadowRootPushed(context.Context) (cdpevent.DOMShadowRootPushedClient, error)

	// Event ShadowRootPopped
	//
	// Called when shadow root is popped from the element.
	ShadowRootPopped(context.Context) (cdpevent.DOMShadowRootPoppedClient, error)

	// Event PseudoElementAdded
	//
	// Called when a pseudo element is added to an element.
	PseudoElementAdded(context.Context) (cdpevent.DOMPseudoElementAddedClient, error)

	// Event PseudoElementRemoved
	//
	// Called when a pseudo element is removed from an element.
	PseudoElementRemoved(context.Context) (cdpevent.DOMPseudoElementRemovedClient, error)

	// Event DistributedNodesUpdated
	//
	// Called when distrubution is changed.
	DistributedNodesUpdated(context.Context) (cdpevent.DOMDistributedNodesUpdatedClient, error)

	// Event NodeHighlightRequested
	//
	//
	NodeHighlightRequested(context.Context) (cdpevent.DOMNodeHighlightRequestedClient, error)
}

// domDomain implements the DOM domain.
type domDomain struct{ conn *rpcc.Conn }

func (d *domDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "Enable", Err: err}
	}
	return
}

func (d *domDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "Disable", Err: err}
	}
	return
}

func (d *domDomain) GetDocument(ctx context.Context, args *cdpcmd.DOMGetDocumentArgs) (reply *cdpcmd.DOMGetDocumentReply, err error) {
	reply = new(cdpcmd.DOMGetDocumentReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetDocument.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetDocument", Err: err}
	}
	return
}

// NewDOMGetDocumentArgs initializes the arguments for GetDocument.
func NewDOMGetDocumentArgs() *cdpcmd.DOMGetDocumentArgs {
	args := new(cdpcmd.DOMGetDocumentArgs)

	return args
}

func (d *domDomain) GetFlattenedDocument(ctx context.Context, args *cdpcmd.DOMGetFlattenedDocumentArgs) (reply *cdpcmd.DOMGetFlattenedDocumentReply, err error) {
	reply = new(cdpcmd.DOMGetFlattenedDocumentReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetFlattenedDocument.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetFlattenedDocument", Err: err}
	}
	return
}

// NewDOMGetFlattenedDocumentArgs initializes the arguments for GetFlattenedDocument.
func NewDOMGetFlattenedDocumentArgs() *cdpcmd.DOMGetFlattenedDocumentArgs {
	args := new(cdpcmd.DOMGetFlattenedDocumentArgs)

	return args
}

func (d *domDomain) CollectClassNamesFromSubtree(ctx context.Context, args *cdpcmd.DOMCollectClassNamesFromSubtreeArgs) (reply *cdpcmd.DOMCollectClassNamesFromSubtreeReply, err error) {
	reply = new(cdpcmd.DOMCollectClassNamesFromSubtreeReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMCollectClassNamesFromSubtree.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "CollectClassNamesFromSubtree", Err: err}
	}
	return
}

// NewDOMCollectClassNamesFromSubtreeArgs initializes the arguments for CollectClassNamesFromSubtree.
func NewDOMCollectClassNamesFromSubtreeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMCollectClassNamesFromSubtreeArgs {
	args := new(cdpcmd.DOMCollectClassNamesFromSubtreeArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) RequestChildNodes(ctx context.Context, args *cdpcmd.DOMRequestChildNodesArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMRequestChildNodes.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "RequestChildNodes", Err: err}
	}
	return
}

// NewDOMRequestChildNodesArgs initializes the arguments for RequestChildNodes.
func NewDOMRequestChildNodesArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMRequestChildNodesArgs {
	args := new(cdpcmd.DOMRequestChildNodesArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) QuerySelector(ctx context.Context, args *cdpcmd.DOMQuerySelectorArgs) (reply *cdpcmd.DOMQuerySelectorReply, err error) {
	reply = new(cdpcmd.DOMQuerySelectorReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMQuerySelector.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "QuerySelector", Err: err}
	}
	return
}

// NewDOMQuerySelectorArgs initializes the arguments for QuerySelector.
func NewDOMQuerySelectorArgs(nodeID cdptype.DOMNodeID, selector string) *cdpcmd.DOMQuerySelectorArgs {
	args := new(cdpcmd.DOMQuerySelectorArgs)
	args.NodeID = nodeID
	args.Selector = selector
	return args
}

func (d *domDomain) QuerySelectorAll(ctx context.Context, args *cdpcmd.DOMQuerySelectorAllArgs) (reply *cdpcmd.DOMQuerySelectorAllReply, err error) {
	reply = new(cdpcmd.DOMQuerySelectorAllReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMQuerySelectorAll.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "QuerySelectorAll", Err: err}
	}
	return
}

// NewDOMQuerySelectorAllArgs initializes the arguments for QuerySelectorAll.
func NewDOMQuerySelectorAllArgs(nodeID cdptype.DOMNodeID, selector string) *cdpcmd.DOMQuerySelectorAllArgs {
	args := new(cdpcmd.DOMQuerySelectorAllArgs)
	args.NodeID = nodeID
	args.Selector = selector
	return args
}

func (d *domDomain) SetNodeName(ctx context.Context, args *cdpcmd.DOMSetNodeNameArgs) (reply *cdpcmd.DOMSetNodeNameReply, err error) {
	reply = new(cdpcmd.DOMSetNodeNameReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMSetNodeName.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "SetNodeName", Err: err}
	}
	return
}

// NewDOMSetNodeNameArgs initializes the arguments for SetNodeName.
func NewDOMSetNodeNameArgs(nodeID cdptype.DOMNodeID, name string) *cdpcmd.DOMSetNodeNameArgs {
	args := new(cdpcmd.DOMSetNodeNameArgs)
	args.NodeID = nodeID
	args.Name = name
	return args
}

func (d *domDomain) SetNodeValue(ctx context.Context, args *cdpcmd.DOMSetNodeValueArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMSetNodeValue.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "SetNodeValue", Err: err}
	}
	return
}

// NewDOMSetNodeValueArgs initializes the arguments for SetNodeValue.
func NewDOMSetNodeValueArgs(nodeID cdptype.DOMNodeID, value string) *cdpcmd.DOMSetNodeValueArgs {
	args := new(cdpcmd.DOMSetNodeValueArgs)
	args.NodeID = nodeID
	args.Value = value
	return args
}

func (d *domDomain) RemoveNode(ctx context.Context, args *cdpcmd.DOMRemoveNodeArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMRemoveNode.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "RemoveNode", Err: err}
	}
	return
}

// NewDOMRemoveNodeArgs initializes the arguments for RemoveNode.
func NewDOMRemoveNodeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMRemoveNodeArgs {
	args := new(cdpcmd.DOMRemoveNodeArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) SetAttributeValue(ctx context.Context, args *cdpcmd.DOMSetAttributeValueArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMSetAttributeValue.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "SetAttributeValue", Err: err}
	}
	return
}

// NewDOMSetAttributeValueArgs initializes the arguments for SetAttributeValue.
func NewDOMSetAttributeValueArgs(nodeID cdptype.DOMNodeID, name string, value string) *cdpcmd.DOMSetAttributeValueArgs {
	args := new(cdpcmd.DOMSetAttributeValueArgs)
	args.NodeID = nodeID
	args.Name = name
	args.Value = value
	return args
}

func (d *domDomain) SetAttributesAsText(ctx context.Context, args *cdpcmd.DOMSetAttributesAsTextArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMSetAttributesAsText.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "SetAttributesAsText", Err: err}
	}
	return
}

// NewDOMSetAttributesAsTextArgs initializes the arguments for SetAttributesAsText.
func NewDOMSetAttributesAsTextArgs(nodeID cdptype.DOMNodeID, text string) *cdpcmd.DOMSetAttributesAsTextArgs {
	args := new(cdpcmd.DOMSetAttributesAsTextArgs)
	args.NodeID = nodeID
	args.Text = text
	return args
}

func (d *domDomain) RemoveAttribute(ctx context.Context, args *cdpcmd.DOMRemoveAttributeArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMRemoveAttribute.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "RemoveAttribute", Err: err}
	}
	return
}

// NewDOMRemoveAttributeArgs initializes the arguments for RemoveAttribute.
func NewDOMRemoveAttributeArgs(nodeID cdptype.DOMNodeID, name string) *cdpcmd.DOMRemoveAttributeArgs {
	args := new(cdpcmd.DOMRemoveAttributeArgs)
	args.NodeID = nodeID
	args.Name = name
	return args
}

func (d *domDomain) GetOuterHTML(ctx context.Context, args *cdpcmd.DOMGetOuterHTMLArgs) (reply *cdpcmd.DOMGetOuterHTMLReply, err error) {
	reply = new(cdpcmd.DOMGetOuterHTMLReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetOuterHTML.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetOuterHTML", Err: err}
	}
	return
}

// NewDOMGetOuterHTMLArgs initializes the arguments for GetOuterHTML.
func NewDOMGetOuterHTMLArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMGetOuterHTMLArgs {
	args := new(cdpcmd.DOMGetOuterHTMLArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) SetOuterHTML(ctx context.Context, args *cdpcmd.DOMSetOuterHTMLArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMSetOuterHTML.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "SetOuterHTML", Err: err}
	}
	return
}

// NewDOMSetOuterHTMLArgs initializes the arguments for SetOuterHTML.
func NewDOMSetOuterHTMLArgs(nodeID cdptype.DOMNodeID, outerHTML string) *cdpcmd.DOMSetOuterHTMLArgs {
	args := new(cdpcmd.DOMSetOuterHTMLArgs)
	args.NodeID = nodeID
	args.OuterHTML = outerHTML
	return args
}

func (d *domDomain) PerformSearch(ctx context.Context, args *cdpcmd.DOMPerformSearchArgs) (reply *cdpcmd.DOMPerformSearchReply, err error) {
	reply = new(cdpcmd.DOMPerformSearchReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMPerformSearch.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "PerformSearch", Err: err}
	}
	return
}

// NewDOMPerformSearchArgs initializes the arguments for PerformSearch.
func NewDOMPerformSearchArgs(query string) *cdpcmd.DOMPerformSearchArgs {
	args := new(cdpcmd.DOMPerformSearchArgs)
	args.Query = query
	return args
}

func (d *domDomain) GetSearchResults(ctx context.Context, args *cdpcmd.DOMGetSearchResultsArgs) (reply *cdpcmd.DOMGetSearchResultsReply, err error) {
	reply = new(cdpcmd.DOMGetSearchResultsReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetSearchResults.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetSearchResults", Err: err}
	}
	return
}

// NewDOMGetSearchResultsArgs initializes the arguments for GetSearchResults.
func NewDOMGetSearchResultsArgs(searchID string, fromIndex int, toIndex int) *cdpcmd.DOMGetSearchResultsArgs {
	args := new(cdpcmd.DOMGetSearchResultsArgs)
	args.SearchID = searchID
	args.FromIndex = fromIndex
	args.ToIndex = toIndex
	return args
}

func (d *domDomain) DiscardSearchResults(ctx context.Context, args *cdpcmd.DOMDiscardSearchResultsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDiscardSearchResults.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "DiscardSearchResults", Err: err}
	}
	return
}

// NewDOMDiscardSearchResultsArgs initializes the arguments for DiscardSearchResults.
func NewDOMDiscardSearchResultsArgs(searchID string) *cdpcmd.DOMDiscardSearchResultsArgs {
	args := new(cdpcmd.DOMDiscardSearchResultsArgs)
	args.SearchID = searchID
	return args
}

func (d *domDomain) RequestNode(ctx context.Context, args *cdpcmd.DOMRequestNodeArgs) (reply *cdpcmd.DOMRequestNodeReply, err error) {
	reply = new(cdpcmd.DOMRequestNodeReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMRequestNode.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "RequestNode", Err: err}
	}
	return
}

// NewDOMRequestNodeArgs initializes the arguments for RequestNode.
func NewDOMRequestNodeArgs(objectID cdptype.RuntimeRemoteObjectID) *cdpcmd.DOMRequestNodeArgs {
	args := new(cdpcmd.DOMRequestNodeArgs)
	args.ObjectID = objectID
	return args
}

func (d *domDomain) SetInspectMode(ctx context.Context, args *cdpcmd.DOMSetInspectModeArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMSetInspectMode.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "SetInspectMode", Err: err}
	}
	return
}

// NewDOMSetInspectModeArgs initializes the arguments for SetInspectMode.
func NewDOMSetInspectModeArgs(mode cdptype.DOMInspectMode) *cdpcmd.DOMSetInspectModeArgs {
	args := new(cdpcmd.DOMSetInspectModeArgs)
	args.Mode = mode
	return args
}

func (d *domDomain) HighlightRect(ctx context.Context, args *cdpcmd.DOMHighlightRectArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMHighlightRect.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "HighlightRect", Err: err}
	}
	return
}

// NewDOMHighlightRectArgs initializes the arguments for HighlightRect.
func NewDOMHighlightRectArgs(x int, y int, width int, height int) *cdpcmd.DOMHighlightRectArgs {
	args := new(cdpcmd.DOMHighlightRectArgs)
	args.X = x
	args.Y = y
	args.Width = width
	args.Height = height
	return args
}

func (d *domDomain) HighlightQuad(ctx context.Context, args *cdpcmd.DOMHighlightQuadArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMHighlightQuad.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "HighlightQuad", Err: err}
	}
	return
}

// NewDOMHighlightQuadArgs initializes the arguments for HighlightQuad.
func NewDOMHighlightQuadArgs(quad cdptype.DOMQuad) *cdpcmd.DOMHighlightQuadArgs {
	args := new(cdpcmd.DOMHighlightQuadArgs)
	args.Quad = quad
	return args
}

func (d *domDomain) HighlightNode(ctx context.Context, args *cdpcmd.DOMHighlightNodeArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMHighlightNode.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "HighlightNode", Err: err}
	}
	return
}

// NewDOMHighlightNodeArgs initializes the arguments for HighlightNode.
func NewDOMHighlightNodeArgs(highlightConfig cdptype.DOMHighlightConfig) *cdpcmd.DOMHighlightNodeArgs {
	args := new(cdpcmd.DOMHighlightNodeArgs)
	args.HighlightConfig = highlightConfig
	return args
}

func (d *domDomain) HideHighlight(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMHideHighlight.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "HideHighlight", Err: err}
	}
	return
}

func (d *domDomain) HighlightFrame(ctx context.Context, args *cdpcmd.DOMHighlightFrameArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMHighlightFrame.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "HighlightFrame", Err: err}
	}
	return
}

// NewDOMHighlightFrameArgs initializes the arguments for HighlightFrame.
func NewDOMHighlightFrameArgs(frameID cdptype.PageFrameID) *cdpcmd.DOMHighlightFrameArgs {
	args := new(cdpcmd.DOMHighlightFrameArgs)
	args.FrameID = frameID
	return args
}

func (d *domDomain) PushNodeByPathToFrontend(ctx context.Context, args *cdpcmd.DOMPushNodeByPathToFrontendArgs) (reply *cdpcmd.DOMPushNodeByPathToFrontendReply, err error) {
	reply = new(cdpcmd.DOMPushNodeByPathToFrontendReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMPushNodeByPathToFrontend.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "PushNodeByPathToFrontend", Err: err}
	}
	return
}

// NewDOMPushNodeByPathToFrontendArgs initializes the arguments for PushNodeByPathToFrontend.
func NewDOMPushNodeByPathToFrontendArgs(path string) *cdpcmd.DOMPushNodeByPathToFrontendArgs {
	args := new(cdpcmd.DOMPushNodeByPathToFrontendArgs)
	args.Path = path
	return args
}

func (d *domDomain) PushNodesByBackendIdsToFrontend(ctx context.Context, args *cdpcmd.DOMPushNodesByBackendIdsToFrontendArgs) (reply *cdpcmd.DOMPushNodesByBackendIdsToFrontendReply, err error) {
	reply = new(cdpcmd.DOMPushNodesByBackendIdsToFrontendReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMPushNodesByBackendIdsToFrontend.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "PushNodesByBackendIdsToFrontend", Err: err}
	}
	return
}

// NewDOMPushNodesByBackendIdsToFrontendArgs initializes the arguments for PushNodesByBackendIdsToFrontend.
func NewDOMPushNodesByBackendIdsToFrontendArgs(backendNodeIDs []cdptype.DOMBackendNodeID) *cdpcmd.DOMPushNodesByBackendIdsToFrontendArgs {
	args := new(cdpcmd.DOMPushNodesByBackendIdsToFrontendArgs)
	args.BackendNodeIDs = backendNodeIDs
	return args
}

func (d *domDomain) SetInspectedNode(ctx context.Context, args *cdpcmd.DOMSetInspectedNodeArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMSetInspectedNode.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "SetInspectedNode", Err: err}
	}
	return
}

// NewDOMSetInspectedNodeArgs initializes the arguments for SetInspectedNode.
func NewDOMSetInspectedNodeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMSetInspectedNodeArgs {
	args := new(cdpcmd.DOMSetInspectedNodeArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) ResolveNode(ctx context.Context, args *cdpcmd.DOMResolveNodeArgs) (reply *cdpcmd.DOMResolveNodeReply, err error) {
	reply = new(cdpcmd.DOMResolveNodeReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMResolveNode.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "ResolveNode", Err: err}
	}
	return
}

// NewDOMResolveNodeArgs initializes the arguments for ResolveNode.
func NewDOMResolveNodeArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMResolveNodeArgs {
	args := new(cdpcmd.DOMResolveNodeArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) GetAttributes(ctx context.Context, args *cdpcmd.DOMGetAttributesArgs) (reply *cdpcmd.DOMGetAttributesReply, err error) {
	reply = new(cdpcmd.DOMGetAttributesReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetAttributes.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetAttributes", Err: err}
	}
	return
}

// NewDOMGetAttributesArgs initializes the arguments for GetAttributes.
func NewDOMGetAttributesArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMGetAttributesArgs {
	args := new(cdpcmd.DOMGetAttributesArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) CopyTo(ctx context.Context, args *cdpcmd.DOMCopyToArgs) (reply *cdpcmd.DOMCopyToReply, err error) {
	reply = new(cdpcmd.DOMCopyToReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMCopyTo.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "CopyTo", Err: err}
	}
	return
}

// NewDOMCopyToArgs initializes the arguments for CopyTo.
func NewDOMCopyToArgs(nodeID cdptype.DOMNodeID, targetNodeID cdptype.DOMNodeID) *cdpcmd.DOMCopyToArgs {
	args := new(cdpcmd.DOMCopyToArgs)
	args.NodeID = nodeID
	args.TargetNodeID = targetNodeID
	return args
}

func (d *domDomain) MoveTo(ctx context.Context, args *cdpcmd.DOMMoveToArgs) (reply *cdpcmd.DOMMoveToReply, err error) {
	reply = new(cdpcmd.DOMMoveToReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMMoveTo.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "MoveTo", Err: err}
	}
	return
}

// NewDOMMoveToArgs initializes the arguments for MoveTo.
func NewDOMMoveToArgs(nodeID cdptype.DOMNodeID, targetNodeID cdptype.DOMNodeID) *cdpcmd.DOMMoveToArgs {
	args := new(cdpcmd.DOMMoveToArgs)
	args.NodeID = nodeID
	args.TargetNodeID = targetNodeID
	return args
}

func (d *domDomain) Undo(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMUndo.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "Undo", Err: err}
	}
	return
}

func (d *domDomain) Redo(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMRedo.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "Redo", Err: err}
	}
	return
}

func (d *domDomain) MarkUndoableState(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMMarkUndoableState.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "MarkUndoableState", Err: err}
	}
	return
}

func (d *domDomain) Focus(ctx context.Context, args *cdpcmd.DOMFocusArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMFocus.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "Focus", Err: err}
	}
	return
}

// NewDOMFocusArgs initializes the arguments for Focus.
func NewDOMFocusArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMFocusArgs {
	args := new(cdpcmd.DOMFocusArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) SetFileInputFiles(ctx context.Context, args *cdpcmd.DOMSetFileInputFilesArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMSetFileInputFiles.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "SetFileInputFiles", Err: err}
	}
	return
}

// NewDOMSetFileInputFilesArgs initializes the arguments for SetFileInputFiles.
func NewDOMSetFileInputFilesArgs(nodeID cdptype.DOMNodeID, files []string) *cdpcmd.DOMSetFileInputFilesArgs {
	args := new(cdpcmd.DOMSetFileInputFilesArgs)
	args.NodeID = nodeID
	args.Files = files
	return args
}

func (d *domDomain) GetBoxModel(ctx context.Context, args *cdpcmd.DOMGetBoxModelArgs) (reply *cdpcmd.DOMGetBoxModelReply, err error) {
	reply = new(cdpcmd.DOMGetBoxModelReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetBoxModel.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetBoxModel", Err: err}
	}
	return
}

// NewDOMGetBoxModelArgs initializes the arguments for GetBoxModel.
func NewDOMGetBoxModelArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMGetBoxModelArgs {
	args := new(cdpcmd.DOMGetBoxModelArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) GetNodeForLocation(ctx context.Context, args *cdpcmd.DOMGetNodeForLocationArgs) (reply *cdpcmd.DOMGetNodeForLocationReply, err error) {
	reply = new(cdpcmd.DOMGetNodeForLocationReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetNodeForLocation.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetNodeForLocation", Err: err}
	}
	return
}

// NewDOMGetNodeForLocationArgs initializes the arguments for GetNodeForLocation.
func NewDOMGetNodeForLocationArgs(x int, y int) *cdpcmd.DOMGetNodeForLocationArgs {
	args := new(cdpcmd.DOMGetNodeForLocationArgs)
	args.X = x
	args.Y = y
	return args
}

func (d *domDomain) GetRelayoutBoundary(ctx context.Context, args *cdpcmd.DOMGetRelayoutBoundaryArgs) (reply *cdpcmd.DOMGetRelayoutBoundaryReply, err error) {
	reply = new(cdpcmd.DOMGetRelayoutBoundaryReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetRelayoutBoundary.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetRelayoutBoundary", Err: err}
	}
	return
}

// NewDOMGetRelayoutBoundaryArgs initializes the arguments for GetRelayoutBoundary.
func NewDOMGetRelayoutBoundaryArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMGetRelayoutBoundaryArgs {
	args := new(cdpcmd.DOMGetRelayoutBoundaryArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) GetHighlightObjectForTest(ctx context.Context, args *cdpcmd.DOMGetHighlightObjectForTestArgs) (reply *cdpcmd.DOMGetHighlightObjectForTestReply, err error) {
	reply = new(cdpcmd.DOMGetHighlightObjectForTestReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMGetHighlightObjectForTest.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOM", Op: "GetHighlightObjectForTest", Err: err}
	}
	return
}

// NewDOMGetHighlightObjectForTestArgs initializes the arguments for GetHighlightObjectForTest.
func NewDOMGetHighlightObjectForTestArgs(nodeID cdptype.DOMNodeID) *cdpcmd.DOMGetHighlightObjectForTestArgs {
	args := new(cdpcmd.DOMGetHighlightObjectForTestArgs)
	args.NodeID = nodeID
	return args
}

func (d *domDomain) DocumentUpdated(ctx context.Context) (cdpevent.DOMDocumentUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMDocumentUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domDocumentUpdatedClient{Stream: s}, nil
}

// domDocumentUpdatedClient implements DOMDocumentUpdatedClient.
type domDocumentUpdatedClient struct{ rpcc.Stream }

func (c *domDocumentUpdatedClient) Recv() (*cdpevent.DOMDocumentUpdatedReply, error) {
	event := new(cdpevent.DOMDocumentUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "DocumentUpdated Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) InspectNodeRequested(ctx context.Context) (cdpevent.DOMInspectNodeRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMInspectNodeRequested.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domInspectNodeRequestedClient{Stream: s}, nil
}

// domInspectNodeRequestedClient implements DOMInspectNodeRequestedClient.
type domInspectNodeRequestedClient struct{ rpcc.Stream }

func (c *domInspectNodeRequestedClient) Recv() (*cdpevent.DOMInspectNodeRequestedReply, error) {
	event := new(cdpevent.DOMInspectNodeRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "InspectNodeRequested Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) SetChildNodes(ctx context.Context) (cdpevent.DOMSetChildNodesClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMSetChildNodes.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domSetChildNodesClient{Stream: s}, nil
}

// domSetChildNodesClient implements DOMSetChildNodesClient.
type domSetChildNodesClient struct{ rpcc.Stream }

func (c *domSetChildNodesClient) Recv() (*cdpevent.DOMSetChildNodesReply, error) {
	event := new(cdpevent.DOMSetChildNodesReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "SetChildNodes Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) AttributeModified(ctx context.Context) (cdpevent.DOMAttributeModifiedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMAttributeModified.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domAttributeModifiedClient{Stream: s}, nil
}

// domAttributeModifiedClient implements DOMAttributeModifiedClient.
type domAttributeModifiedClient struct{ rpcc.Stream }

func (c *domAttributeModifiedClient) Recv() (*cdpevent.DOMAttributeModifiedReply, error) {
	event := new(cdpevent.DOMAttributeModifiedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "AttributeModified Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) AttributeRemoved(ctx context.Context) (cdpevent.DOMAttributeRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMAttributeRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domAttributeRemovedClient{Stream: s}, nil
}

// domAttributeRemovedClient implements DOMAttributeRemovedClient.
type domAttributeRemovedClient struct{ rpcc.Stream }

func (c *domAttributeRemovedClient) Recv() (*cdpevent.DOMAttributeRemovedReply, error) {
	event := new(cdpevent.DOMAttributeRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "AttributeRemoved Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) InlineStyleInvalidated(ctx context.Context) (cdpevent.DOMInlineStyleInvalidatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMInlineStyleInvalidated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domInlineStyleInvalidatedClient{Stream: s}, nil
}

// domInlineStyleInvalidatedClient implements DOMInlineStyleInvalidatedClient.
type domInlineStyleInvalidatedClient struct{ rpcc.Stream }

func (c *domInlineStyleInvalidatedClient) Recv() (*cdpevent.DOMInlineStyleInvalidatedReply, error) {
	event := new(cdpevent.DOMInlineStyleInvalidatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "InlineStyleInvalidated Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) CharacterDataModified(ctx context.Context) (cdpevent.DOMCharacterDataModifiedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMCharacterDataModified.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domCharacterDataModifiedClient{Stream: s}, nil
}

// domCharacterDataModifiedClient implements DOMCharacterDataModifiedClient.
type domCharacterDataModifiedClient struct{ rpcc.Stream }

func (c *domCharacterDataModifiedClient) Recv() (*cdpevent.DOMCharacterDataModifiedReply, error) {
	event := new(cdpevent.DOMCharacterDataModifiedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "CharacterDataModified Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) ChildNodeCountUpdated(ctx context.Context) (cdpevent.DOMChildNodeCountUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMChildNodeCountUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domChildNodeCountUpdatedClient{Stream: s}, nil
}

// domChildNodeCountUpdatedClient implements DOMChildNodeCountUpdatedClient.
type domChildNodeCountUpdatedClient struct{ rpcc.Stream }

func (c *domChildNodeCountUpdatedClient) Recv() (*cdpevent.DOMChildNodeCountUpdatedReply, error) {
	event := new(cdpevent.DOMChildNodeCountUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "ChildNodeCountUpdated Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) ChildNodeInserted(ctx context.Context) (cdpevent.DOMChildNodeInsertedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMChildNodeInserted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domChildNodeInsertedClient{Stream: s}, nil
}

// domChildNodeInsertedClient implements DOMChildNodeInsertedClient.
type domChildNodeInsertedClient struct{ rpcc.Stream }

func (c *domChildNodeInsertedClient) Recv() (*cdpevent.DOMChildNodeInsertedReply, error) {
	event := new(cdpevent.DOMChildNodeInsertedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "ChildNodeInserted Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) ChildNodeRemoved(ctx context.Context) (cdpevent.DOMChildNodeRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMChildNodeRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domChildNodeRemovedClient{Stream: s}, nil
}

// domChildNodeRemovedClient implements DOMChildNodeRemovedClient.
type domChildNodeRemovedClient struct{ rpcc.Stream }

func (c *domChildNodeRemovedClient) Recv() (*cdpevent.DOMChildNodeRemovedReply, error) {
	event := new(cdpevent.DOMChildNodeRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "ChildNodeRemoved Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) ShadowRootPushed(ctx context.Context) (cdpevent.DOMShadowRootPushedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMShadowRootPushed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domShadowRootPushedClient{Stream: s}, nil
}

// domShadowRootPushedClient implements DOMShadowRootPushedClient.
type domShadowRootPushedClient struct{ rpcc.Stream }

func (c *domShadowRootPushedClient) Recv() (*cdpevent.DOMShadowRootPushedReply, error) {
	event := new(cdpevent.DOMShadowRootPushedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "ShadowRootPushed Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) ShadowRootPopped(ctx context.Context) (cdpevent.DOMShadowRootPoppedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMShadowRootPopped.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domShadowRootPoppedClient{Stream: s}, nil
}

// domShadowRootPoppedClient implements DOMShadowRootPoppedClient.
type domShadowRootPoppedClient struct{ rpcc.Stream }

func (c *domShadowRootPoppedClient) Recv() (*cdpevent.DOMShadowRootPoppedReply, error) {
	event := new(cdpevent.DOMShadowRootPoppedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "ShadowRootPopped Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) PseudoElementAdded(ctx context.Context) (cdpevent.DOMPseudoElementAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMPseudoElementAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domPseudoElementAddedClient{Stream: s}, nil
}

// domPseudoElementAddedClient implements DOMPseudoElementAddedClient.
type domPseudoElementAddedClient struct{ rpcc.Stream }

func (c *domPseudoElementAddedClient) Recv() (*cdpevent.DOMPseudoElementAddedReply, error) {
	event := new(cdpevent.DOMPseudoElementAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "PseudoElementAdded Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) PseudoElementRemoved(ctx context.Context) (cdpevent.DOMPseudoElementRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMPseudoElementRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domPseudoElementRemovedClient{Stream: s}, nil
}

// domPseudoElementRemovedClient implements DOMPseudoElementRemovedClient.
type domPseudoElementRemovedClient struct{ rpcc.Stream }

func (c *domPseudoElementRemovedClient) Recv() (*cdpevent.DOMPseudoElementRemovedReply, error) {
	event := new(cdpevent.DOMPseudoElementRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "PseudoElementRemoved Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) DistributedNodesUpdated(ctx context.Context) (cdpevent.DOMDistributedNodesUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMDistributedNodesUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domDistributedNodesUpdatedClient{Stream: s}, nil
}

// domDistributedNodesUpdatedClient implements DOMDistributedNodesUpdatedClient.
type domDistributedNodesUpdatedClient struct{ rpcc.Stream }

func (c *domDistributedNodesUpdatedClient) Recv() (*cdpevent.DOMDistributedNodesUpdatedReply, error) {
	event := new(cdpevent.DOMDistributedNodesUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "DistributedNodesUpdated Recv", Err: err}
	}
	return event, nil
}

func (d *domDomain) NodeHighlightRequested(ctx context.Context) (cdpevent.DOMNodeHighlightRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMNodeHighlightRequested.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domNodeHighlightRequestedClient{Stream: s}, nil
}

// domNodeHighlightRequestedClient implements DOMNodeHighlightRequestedClient.
type domNodeHighlightRequestedClient struct{ rpcc.Stream }

func (c *domNodeHighlightRequestedClient) Recv() (*cdpevent.DOMNodeHighlightRequestedReply, error) {
	event := new(cdpevent.DOMNodeHighlightRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOM", Op: "NodeHighlightRequested Recv", Err: err}
	}
	return event, nil
}

// The DOMDebugger domain. DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript execution will stop on these operations as if there was a regular breakpoint set.
type DOMDebugger interface {
	// Command SetDOMBreakpoint
	//
	// Sets breakpoint on particular operation with DOM.
	SetDOMBreakpoint(context.Context, *cdpcmd.DOMDebuggerSetDOMBreakpointArgs) error

	// Command RemoveDOMBreakpoint
	//
	// Removes DOM breakpoint that was set using setDOMBreakpoint.
	RemoveDOMBreakpoint(context.Context, *cdpcmd.DOMDebuggerRemoveDOMBreakpointArgs) error

	// Command SetEventListenerBreakpoint
	//
	// Sets breakpoint on particular DOM event.
	SetEventListenerBreakpoint(context.Context, *cdpcmd.DOMDebuggerSetEventListenerBreakpointArgs) error

	// Command RemoveEventListenerBreakpoint
	//
	// Removes breakpoint on particular DOM event.
	RemoveEventListenerBreakpoint(context.Context, *cdpcmd.DOMDebuggerRemoveEventListenerBreakpointArgs) error

	// Command SetInstrumentationBreakpoint
	//
	// Sets breakpoint on particular native event.
	SetInstrumentationBreakpoint(context.Context, *cdpcmd.DOMDebuggerSetInstrumentationBreakpointArgs) error

	// Command RemoveInstrumentationBreakpoint
	//
	// Removes breakpoint on particular native event.
	RemoveInstrumentationBreakpoint(context.Context, *cdpcmd.DOMDebuggerRemoveInstrumentationBreakpointArgs) error

	// Command SetXHRBreakpoint
	//
	// Sets breakpoint on XMLHttpRequest.
	SetXHRBreakpoint(context.Context, *cdpcmd.DOMDebuggerSetXHRBreakpointArgs) error

	// Command RemoveXHRBreakpoint
	//
	// Removes breakpoint from XMLHttpRequest.
	RemoveXHRBreakpoint(context.Context, *cdpcmd.DOMDebuggerRemoveXHRBreakpointArgs) error

	// Command GetEventListeners
	//
	// Returns event listeners of the given object.
	GetEventListeners(context.Context, *cdpcmd.DOMDebuggerGetEventListenersArgs) (*cdpcmd.DOMDebuggerGetEventListenersReply, error)
}

// domdebuggerDomain implements the DOMDebugger domain.
type domdebuggerDomain struct{ conn *rpcc.Conn }

func (d *domdebuggerDomain) SetDOMBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerSetDOMBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetDOMBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "SetDOMBreakpoint", Err: err}
	}
	return
}

// NewDOMDebuggerSetDOMBreakpointArgs initializes the arguments for SetDOMBreakpoint.
func NewDOMDebuggerSetDOMBreakpointArgs(nodeID cdptype.DOMNodeID, typ cdptype.DOMDebuggerDOMBreakpointType) *cdpcmd.DOMDebuggerSetDOMBreakpointArgs {
	args := new(cdpcmd.DOMDebuggerSetDOMBreakpointArgs)
	args.NodeID = nodeID
	args.Type = typ
	return args
}

func (d *domdebuggerDomain) RemoveDOMBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerRemoveDOMBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveDOMBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "RemoveDOMBreakpoint", Err: err}
	}
	return
}

// NewDOMDebuggerRemoveDOMBreakpointArgs initializes the arguments for RemoveDOMBreakpoint.
func NewDOMDebuggerRemoveDOMBreakpointArgs(nodeID cdptype.DOMNodeID, typ cdptype.DOMDebuggerDOMBreakpointType) *cdpcmd.DOMDebuggerRemoveDOMBreakpointArgs {
	args := new(cdpcmd.DOMDebuggerRemoveDOMBreakpointArgs)
	args.NodeID = nodeID
	args.Type = typ
	return args
}

func (d *domdebuggerDomain) SetEventListenerBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerSetEventListenerBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetEventListenerBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "SetEventListenerBreakpoint", Err: err}
	}
	return
}

// NewDOMDebuggerSetEventListenerBreakpointArgs initializes the arguments for SetEventListenerBreakpoint.
func NewDOMDebuggerSetEventListenerBreakpointArgs(eventName string) *cdpcmd.DOMDebuggerSetEventListenerBreakpointArgs {
	args := new(cdpcmd.DOMDebuggerSetEventListenerBreakpointArgs)
	args.EventName = eventName
	return args
}

func (d *domdebuggerDomain) RemoveEventListenerBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerRemoveEventListenerBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveEventListenerBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "RemoveEventListenerBreakpoint", Err: err}
	}
	return
}

// NewDOMDebuggerRemoveEventListenerBreakpointArgs initializes the arguments for RemoveEventListenerBreakpoint.
func NewDOMDebuggerRemoveEventListenerBreakpointArgs(eventName string) *cdpcmd.DOMDebuggerRemoveEventListenerBreakpointArgs {
	args := new(cdpcmd.DOMDebuggerRemoveEventListenerBreakpointArgs)
	args.EventName = eventName
	return args
}

func (d *domdebuggerDomain) SetInstrumentationBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerSetInstrumentationBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetInstrumentationBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "SetInstrumentationBreakpoint", Err: err}
	}
	return
}

// NewDOMDebuggerSetInstrumentationBreakpointArgs initializes the arguments for SetInstrumentationBreakpoint.
func NewDOMDebuggerSetInstrumentationBreakpointArgs(eventName string) *cdpcmd.DOMDebuggerSetInstrumentationBreakpointArgs {
	args := new(cdpcmd.DOMDebuggerSetInstrumentationBreakpointArgs)
	args.EventName = eventName
	return args
}

func (d *domdebuggerDomain) RemoveInstrumentationBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerRemoveInstrumentationBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveInstrumentationBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "RemoveInstrumentationBreakpoint", Err: err}
	}
	return
}

// NewDOMDebuggerRemoveInstrumentationBreakpointArgs initializes the arguments for RemoveInstrumentationBreakpoint.
func NewDOMDebuggerRemoveInstrumentationBreakpointArgs(eventName string) *cdpcmd.DOMDebuggerRemoveInstrumentationBreakpointArgs {
	args := new(cdpcmd.DOMDebuggerRemoveInstrumentationBreakpointArgs)
	args.EventName = eventName
	return args
}

func (d *domdebuggerDomain) SetXHRBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerSetXHRBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetXHRBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "SetXHRBreakpoint", Err: err}
	}
	return
}

// NewDOMDebuggerSetXHRBreakpointArgs initializes the arguments for SetXHRBreakpoint.
func NewDOMDebuggerSetXHRBreakpointArgs(url string) *cdpcmd.DOMDebuggerSetXHRBreakpointArgs {
	args := new(cdpcmd.DOMDebuggerSetXHRBreakpointArgs)
	args.URL = url
	return args
}

func (d *domdebuggerDomain) RemoveXHRBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerRemoveXHRBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveXHRBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "RemoveXHRBreakpoint", Err: err}
	}
	return
}

// NewDOMDebuggerRemoveXHRBreakpointArgs initializes the arguments for RemoveXHRBreakpoint.
func NewDOMDebuggerRemoveXHRBreakpointArgs(url string) *cdpcmd.DOMDebuggerRemoveXHRBreakpointArgs {
	args := new(cdpcmd.DOMDebuggerRemoveXHRBreakpointArgs)
	args.URL = url
	return args
}

func (d *domdebuggerDomain) GetEventListeners(ctx context.Context, args *cdpcmd.DOMDebuggerGetEventListenersArgs) (reply *cdpcmd.DOMDebuggerGetEventListenersReply, err error) {
	reply = new(cdpcmd.DOMDebuggerGetEventListenersReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerGetEventListeners.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMDebugger", Op: "GetEventListeners", Err: err}
	}
	return
}

// NewDOMDebuggerGetEventListenersArgs initializes the arguments for GetEventListeners.
func NewDOMDebuggerGetEventListenersArgs(objectID cdptype.RuntimeRemoteObjectID) *cdpcmd.DOMDebuggerGetEventListenersArgs {
	args := new(cdpcmd.DOMDebuggerGetEventListenersArgs)
	args.ObjectID = objectID
	return args
}

// The DOMStorage domain. Query and modify DOM storage.
type DOMStorage interface {
	// Command Enable
	//
	// Enables storage tracking, storage events will now be delivered to the client.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables storage tracking, prevents storage events from being sent to the client.
	Disable(context.Context) error

	// Command Clear
	//
	//
	Clear(context.Context, *cdpcmd.DOMStorageClearArgs) error

	// Command GetDOMStorageItems
	//
	//
	GetDOMStorageItems(context.Context, *cdpcmd.DOMStorageGetDOMStorageItemsArgs) (*cdpcmd.DOMStorageGetDOMStorageItemsReply, error)

	// Command SetDOMStorageItem
	//
	//
	SetDOMStorageItem(context.Context, *cdpcmd.DOMStorageSetDOMStorageItemArgs) error

	// Command RemoveDOMStorageItem
	//
	//
	RemoveDOMStorageItem(context.Context, *cdpcmd.DOMStorageRemoveDOMStorageItemArgs) error

	// Event DOMStorageItemsCleared
	//
	//
	DOMStorageItemsCleared(context.Context) (cdpevent.DOMStorageItemsClearedClient, error)

	// Event DOMStorageItemRemoved
	//
	//
	DOMStorageItemRemoved(context.Context) (cdpevent.DOMStorageItemRemovedClient, error)

	// Event DOMStorageItemAdded
	//
	//
	DOMStorageItemAdded(context.Context) (cdpevent.DOMStorageItemAddedClient, error)

	// Event DOMStorageItemUpdated
	//
	//
	DOMStorageItemUpdated(context.Context) (cdpevent.DOMStorageItemUpdatedClient, error)
}

// domstorageDomain implements the DOMStorage domain.
type domstorageDomain struct{ conn *rpcc.Conn }

func (d *domstorageDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMStorageEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMStorage", Op: "Enable", Err: err}
	}
	return
}

func (d *domstorageDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMStorageDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMStorage", Op: "Disable", Err: err}
	}
	return
}

func (d *domstorageDomain) Clear(ctx context.Context, args *cdpcmd.DOMStorageClearArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMStorageClear.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMStorage", Op: "Clear", Err: err}
	}
	return
}

// NewDOMStorageClearArgs initializes the arguments for Clear.
func NewDOMStorageClearArgs(storageID cdptype.DOMStorageStorageID) *cdpcmd.DOMStorageClearArgs {
	args := new(cdpcmd.DOMStorageClearArgs)
	args.StorageID = storageID
	return args
}

func (d *domstorageDomain) GetDOMStorageItems(ctx context.Context, args *cdpcmd.DOMStorageGetDOMStorageItemsArgs) (reply *cdpcmd.DOMStorageGetDOMStorageItemsReply, err error) {
	reply = new(cdpcmd.DOMStorageGetDOMStorageItemsReply)

	err = rpcc.Invoke(ctx, cdpcmd.DOMStorageGetDOMStorageItems.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMStorage", Op: "GetDOMStorageItems", Err: err}
	}
	return
}

// NewDOMStorageGetDOMStorageItemsArgs initializes the arguments for GetDOMStorageItems.
func NewDOMStorageGetDOMStorageItemsArgs(storageID cdptype.DOMStorageStorageID) *cdpcmd.DOMStorageGetDOMStorageItemsArgs {
	args := new(cdpcmd.DOMStorageGetDOMStorageItemsArgs)
	args.StorageID = storageID
	return args
}

func (d *domstorageDomain) SetDOMStorageItem(ctx context.Context, args *cdpcmd.DOMStorageSetDOMStorageItemArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMStorageSetDOMStorageItem.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMStorage", Op: "SetDOMStorageItem", Err: err}
	}
	return
}

// NewDOMStorageSetDOMStorageItemArgs initializes the arguments for SetDOMStorageItem.
func NewDOMStorageSetDOMStorageItemArgs(storageID cdptype.DOMStorageStorageID, key string, value string) *cdpcmd.DOMStorageSetDOMStorageItemArgs {
	args := new(cdpcmd.DOMStorageSetDOMStorageItemArgs)
	args.StorageID = storageID
	args.Key = key
	args.Value = value
	return args
}

func (d *domstorageDomain) RemoveDOMStorageItem(ctx context.Context, args *cdpcmd.DOMStorageRemoveDOMStorageItemArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DOMStorageRemoveDOMStorageItem.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DOMStorage", Op: "RemoveDOMStorageItem", Err: err}
	}
	return
}

// NewDOMStorageRemoveDOMStorageItemArgs initializes the arguments for RemoveDOMStorageItem.
func NewDOMStorageRemoveDOMStorageItemArgs(storageID cdptype.DOMStorageStorageID, key string) *cdpcmd.DOMStorageRemoveDOMStorageItemArgs {
	args := new(cdpcmd.DOMStorageRemoveDOMStorageItemArgs)
	args.StorageID = storageID
	args.Key = key
	return args
}

func (d *domstorageDomain) DOMStorageItemsCleared(ctx context.Context) (cdpevent.DOMStorageItemsClearedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMStorageItemsCleared.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domstorageDOMStorageItemsClearedClient{Stream: s}, nil
}

// domstorageDOMStorageItemsClearedClient implements DOMStorageItemsClearedClient.
type domstorageDOMStorageItemsClearedClient struct{ rpcc.Stream }

func (c *domstorageDOMStorageItemsClearedClient) Recv() (*cdpevent.DOMStorageItemsClearedReply, error) {
	event := new(cdpevent.DOMStorageItemsClearedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOMStorage", Op: "DOMStorageItemsCleared Recv", Err: err}
	}
	return event, nil
}

func (d *domstorageDomain) DOMStorageItemRemoved(ctx context.Context) (cdpevent.DOMStorageItemRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMStorageItemRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domstorageDOMStorageItemRemovedClient{Stream: s}, nil
}

// domstorageDOMStorageItemRemovedClient implements DOMStorageItemRemovedClient.
type domstorageDOMStorageItemRemovedClient struct{ rpcc.Stream }

func (c *domstorageDOMStorageItemRemovedClient) Recv() (*cdpevent.DOMStorageItemRemovedReply, error) {
	event := new(cdpevent.DOMStorageItemRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOMStorage", Op: "DOMStorageItemRemoved Recv", Err: err}
	}
	return event, nil
}

func (d *domstorageDomain) DOMStorageItemAdded(ctx context.Context) (cdpevent.DOMStorageItemAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMStorageItemAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domstorageDOMStorageItemAddedClient{Stream: s}, nil
}

// domstorageDOMStorageItemAddedClient implements DOMStorageItemAddedClient.
type domstorageDOMStorageItemAddedClient struct{ rpcc.Stream }

func (c *domstorageDOMStorageItemAddedClient) Recv() (*cdpevent.DOMStorageItemAddedReply, error) {
	event := new(cdpevent.DOMStorageItemAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOMStorage", Op: "DOMStorageItemAdded Recv", Err: err}
	}
	return event, nil
}

func (d *domstorageDomain) DOMStorageItemUpdated(ctx context.Context) (cdpevent.DOMStorageItemUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMStorageItemUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &domstorageDOMStorageItemUpdatedClient{Stream: s}, nil
}

// domstorageDOMStorageItemUpdatedClient implements DOMStorageItemUpdatedClient.
type domstorageDOMStorageItemUpdatedClient struct{ rpcc.Stream }

func (c *domstorageDOMStorageItemUpdatedClient) Recv() (*cdpevent.DOMStorageItemUpdatedReply, error) {
	event := new(cdpevent.DOMStorageItemUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "DOMStorage", Op: "DOMStorageItemUpdated Recv", Err: err}
	}
	return event, nil
}

// The Database domain.
type Database interface {
	// Command Enable
	//
	// Enables database tracking, database events will now be delivered to the client.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables database tracking, prevents database events from being sent to the client.
	Disable(context.Context) error

	// Command GetDatabaseTableNames
	//
	//
	GetDatabaseTableNames(context.Context, *cdpcmd.DatabaseGetDatabaseTableNamesArgs) (*cdpcmd.DatabaseGetDatabaseTableNamesReply, error)

	// Command ExecuteSQL
	//
	//
	ExecuteSQL(context.Context, *cdpcmd.DatabaseExecuteSQLArgs) (*cdpcmd.DatabaseExecuteSQLReply, error)

	// Event AddDatabase
	//
	//
	AddDatabase(context.Context) (cdpevent.DatabaseAddDatabaseClient, error)
}

// databaseDomain implements the Database domain.
type databaseDomain struct{ conn *rpcc.Conn }

func (d *databaseDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DatabaseEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Database", Op: "Enable", Err: err}
	}
	return
}

func (d *databaseDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DatabaseDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Database", Op: "Disable", Err: err}
	}
	return
}

func (d *databaseDomain) GetDatabaseTableNames(ctx context.Context, args *cdpcmd.DatabaseGetDatabaseTableNamesArgs) (reply *cdpcmd.DatabaseGetDatabaseTableNamesReply, err error) {
	reply = new(cdpcmd.DatabaseGetDatabaseTableNamesReply)

	err = rpcc.Invoke(ctx, cdpcmd.DatabaseGetDatabaseTableNames.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Database", Op: "GetDatabaseTableNames", Err: err}
	}
	return
}

// NewDatabaseGetDatabaseTableNamesArgs initializes the arguments for GetDatabaseTableNames.
func NewDatabaseGetDatabaseTableNamesArgs(databaseID cdptype.DatabaseID) *cdpcmd.DatabaseGetDatabaseTableNamesArgs {
	args := new(cdpcmd.DatabaseGetDatabaseTableNamesArgs)
	args.DatabaseID = databaseID
	return args
}

func (d *databaseDomain) ExecuteSQL(ctx context.Context, args *cdpcmd.DatabaseExecuteSQLArgs) (reply *cdpcmd.DatabaseExecuteSQLReply, err error) {
	reply = new(cdpcmd.DatabaseExecuteSQLReply)

	err = rpcc.Invoke(ctx, cdpcmd.DatabaseExecuteSQL.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Database", Op: "ExecuteSQL", Err: err}
	}
	return
}

// NewDatabaseExecuteSQLArgs initializes the arguments for ExecuteSQL.
func NewDatabaseExecuteSQLArgs(databaseID cdptype.DatabaseID, query string) *cdpcmd.DatabaseExecuteSQLArgs {
	args := new(cdpcmd.DatabaseExecuteSQLArgs)
	args.DatabaseID = databaseID
	args.Query = query
	return args
}

func (d *databaseDomain) AddDatabase(ctx context.Context) (cdpevent.DatabaseAddDatabaseClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DatabaseAddDatabase.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &databaseAddDatabaseClient{Stream: s}, nil
}

// databaseAddDatabaseClient implements DatabaseAddDatabaseClient.
type databaseAddDatabaseClient struct{ rpcc.Stream }

func (c *databaseAddDatabaseClient) Recv() (*cdpevent.DatabaseAddDatabaseReply, error) {
	event := new(cdpevent.DatabaseAddDatabaseReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Database", Op: "AddDatabase Recv", Err: err}
	}
	return event, nil
}

// The Debugger domain. Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.
type Debugger interface {
	// Command Enable
	//
	// Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables debugger for given page.
	Disable(context.Context) error

	// Command SetBreakpointsActive
	//
	// Activates / deactivates all breakpoints on the page.
	SetBreakpointsActive(context.Context, *cdpcmd.DebuggerSetBreakpointsActiveArgs) error

	// Command SetSkipAllPauses
	//
	// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
	SetSkipAllPauses(context.Context, *cdpcmd.DebuggerSetSkipAllPausesArgs) error

	// Command SetBreakpointByURL
	//
	// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in locations property. Further matching script parsing will result in subsequent breakpointResolved events issued. This logical breakpoint will survive page reloads.
	SetBreakpointByURL(context.Context, *cdpcmd.DebuggerSetBreakpointByURLArgs) (*cdpcmd.DebuggerSetBreakpointByURLReply, error)

	// Command SetBreakpoint
	//
	// Sets JavaScript breakpoint at a given location.
	SetBreakpoint(context.Context, *cdpcmd.DebuggerSetBreakpointArgs) (*cdpcmd.DebuggerSetBreakpointReply, error)

	// Command RemoveBreakpoint
	//
	// Removes JavaScript breakpoint.
	RemoveBreakpoint(context.Context, *cdpcmd.DebuggerRemoveBreakpointArgs) error

	// Command GetPossibleBreakpoints
	//
	// Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
	GetPossibleBreakpoints(context.Context, *cdpcmd.DebuggerGetPossibleBreakpointsArgs) (*cdpcmd.DebuggerGetPossibleBreakpointsReply, error)

	// Command ContinueToLocation
	//
	// Continues execution until specific location is reached.
	ContinueToLocation(context.Context, *cdpcmd.DebuggerContinueToLocationArgs) error

	// Command StepOver
	//
	// Steps over the statement.
	StepOver(context.Context) error

	// Command StepInto
	//
	// Steps into the function call.
	StepInto(context.Context) error

	// Command StepOut
	//
	// Steps out of the function call.
	StepOut(context.Context) error

	// Command Pause
	//
	// Stops on the next JavaScript statement.
	Pause(context.Context) error

	// Command ScheduleStepIntoAsync
	//
	// Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
	ScheduleStepIntoAsync(context.Context) error

	// Command Resume
	//
	// Resumes JavaScript execution.
	Resume(context.Context) error

	// Command SearchInContent
	//
	// Searches for given string in script content.
	SearchInContent(context.Context, *cdpcmd.DebuggerSearchInContentArgs) (*cdpcmd.DebuggerSearchInContentReply, error)

	// Command SetScriptSource
	//
	// Edits JavaScript source live.
	SetScriptSource(context.Context, *cdpcmd.DebuggerSetScriptSourceArgs) (*cdpcmd.DebuggerSetScriptSourceReply, error)

	// Command RestartFrame
	//
	// Restarts particular call frame from the beginning.
	RestartFrame(context.Context, *cdpcmd.DebuggerRestartFrameArgs) (*cdpcmd.DebuggerRestartFrameReply, error)

	// Command GetScriptSource
	//
	// Returns source for the script with given id.
	GetScriptSource(context.Context, *cdpcmd.DebuggerGetScriptSourceArgs) (*cdpcmd.DebuggerGetScriptSourceReply, error)

	// Command SetPauseOnExceptions
	//
	// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is none.
	SetPauseOnExceptions(context.Context, *cdpcmd.DebuggerSetPauseOnExceptionsArgs) error

	// Command EvaluateOnCallFrame
	//
	// Evaluates expression on a given call frame.
	EvaluateOnCallFrame(context.Context, *cdpcmd.DebuggerEvaluateOnCallFrameArgs) (*cdpcmd.DebuggerEvaluateOnCallFrameReply, error)

	// Command SetVariableValue
	//
	// Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
	SetVariableValue(context.Context, *cdpcmd.DebuggerSetVariableValueArgs) error

	// Command SetAsyncCallStackDepth
	//
	// Enables or disables async call stacks tracking.
	SetAsyncCallStackDepth(context.Context, *cdpcmd.DebuggerSetAsyncCallStackDepthArgs) error

	// Command SetBlackboxPatterns
	//
	// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
	SetBlackboxPatterns(context.Context, *cdpcmd.DebuggerSetBlackboxPatternsArgs) error

	// Command SetBlackboxedRanges
	//
	// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
	SetBlackboxedRanges(context.Context, *cdpcmd.DebuggerSetBlackboxedRangesArgs) error

	// Event ScriptParsed
	//
	// Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
	ScriptParsed(context.Context) (cdpevent.DebuggerScriptParsedClient, error)

	// Event ScriptFailedToParse
	//
	// Fired when virtual machine fails to parse the script.
	ScriptFailedToParse(context.Context) (cdpevent.DebuggerScriptFailedToParseClient, error)

	// Event BreakpointResolved
	//
	// Fired when breakpoint is resolved to an actual script and location.
	BreakpointResolved(context.Context) (cdpevent.DebuggerBreakpointResolvedClient, error)

	// Event Paused
	//
	// Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
	Paused(context.Context) (cdpevent.DebuggerPausedClient, error)

	// Event Resumed
	//
	// Fired when the virtual machine resumed execution.
	Resumed(context.Context) (cdpevent.DebuggerResumedClient, error)
}

// debuggerDomain implements the Debugger domain.
type debuggerDomain struct{ conn *rpcc.Conn }

func (d *debuggerDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "Enable", Err: err}
	}
	return
}

func (d *debuggerDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "Disable", Err: err}
	}
	return
}

func (d *debuggerDomain) SetBreakpointsActive(ctx context.Context, args *cdpcmd.DebuggerSetBreakpointsActiveArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpointsActive.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetBreakpointsActive", Err: err}
	}
	return
}

// NewDebuggerSetBreakpointsActiveArgs initializes the arguments for SetBreakpointsActive.
func NewDebuggerSetBreakpointsActiveArgs(active bool) *cdpcmd.DebuggerSetBreakpointsActiveArgs {
	args := new(cdpcmd.DebuggerSetBreakpointsActiveArgs)
	args.Active = active
	return args
}

func (d *debuggerDomain) SetSkipAllPauses(ctx context.Context, args *cdpcmd.DebuggerSetSkipAllPausesArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetSkipAllPauses.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetSkipAllPauses", Err: err}
	}
	return
}

// NewDebuggerSetSkipAllPausesArgs initializes the arguments for SetSkipAllPauses.
func NewDebuggerSetSkipAllPausesArgs(skip bool) *cdpcmd.DebuggerSetSkipAllPausesArgs {
	args := new(cdpcmd.DebuggerSetSkipAllPausesArgs)
	args.Skip = skip
	return args
}

func (d *debuggerDomain) SetBreakpointByURL(ctx context.Context, args *cdpcmd.DebuggerSetBreakpointByURLArgs) (reply *cdpcmd.DebuggerSetBreakpointByURLReply, err error) {
	reply = new(cdpcmd.DebuggerSetBreakpointByURLReply)

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpointByURL.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetBreakpointByURL", Err: err}
	}
	return
}

// NewDebuggerSetBreakpointByURLArgs initializes the arguments for SetBreakpointByURL.
func NewDebuggerSetBreakpointByURLArgs(lineNumber int) *cdpcmd.DebuggerSetBreakpointByURLArgs {
	args := new(cdpcmd.DebuggerSetBreakpointByURLArgs)
	args.LineNumber = lineNumber
	return args
}

func (d *debuggerDomain) SetBreakpoint(ctx context.Context, args *cdpcmd.DebuggerSetBreakpointArgs) (reply *cdpcmd.DebuggerSetBreakpointReply, err error) {
	reply = new(cdpcmd.DebuggerSetBreakpointReply)

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpoint.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetBreakpoint", Err: err}
	}
	return
}

// NewDebuggerSetBreakpointArgs initializes the arguments for SetBreakpoint.
func NewDebuggerSetBreakpointArgs(location cdptype.DebuggerLocation) *cdpcmd.DebuggerSetBreakpointArgs {
	args := new(cdpcmd.DebuggerSetBreakpointArgs)
	args.Location = location
	return args
}

func (d *debuggerDomain) RemoveBreakpoint(ctx context.Context, args *cdpcmd.DebuggerRemoveBreakpointArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerRemoveBreakpoint.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "RemoveBreakpoint", Err: err}
	}
	return
}

// NewDebuggerRemoveBreakpointArgs initializes the arguments for RemoveBreakpoint.
func NewDebuggerRemoveBreakpointArgs(breakpointID cdptype.DebuggerBreakpointID) *cdpcmd.DebuggerRemoveBreakpointArgs {
	args := new(cdpcmd.DebuggerRemoveBreakpointArgs)
	args.BreakpointID = breakpointID
	return args
}

func (d *debuggerDomain) GetPossibleBreakpoints(ctx context.Context, args *cdpcmd.DebuggerGetPossibleBreakpointsArgs) (reply *cdpcmd.DebuggerGetPossibleBreakpointsReply, err error) {
	reply = new(cdpcmd.DebuggerGetPossibleBreakpointsReply)

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerGetPossibleBreakpoints.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "GetPossibleBreakpoints", Err: err}
	}
	return
}

// NewDebuggerGetPossibleBreakpointsArgs initializes the arguments for GetPossibleBreakpoints.
func NewDebuggerGetPossibleBreakpointsArgs(start cdptype.DebuggerLocation) *cdpcmd.DebuggerGetPossibleBreakpointsArgs {
	args := new(cdpcmd.DebuggerGetPossibleBreakpointsArgs)
	args.Start = start
	return args
}

func (d *debuggerDomain) ContinueToLocation(ctx context.Context, args *cdpcmd.DebuggerContinueToLocationArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerContinueToLocation.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "ContinueToLocation", Err: err}
	}
	return
}

// NewDebuggerContinueToLocationArgs initializes the arguments for ContinueToLocation.
func NewDebuggerContinueToLocationArgs(location cdptype.DebuggerLocation) *cdpcmd.DebuggerContinueToLocationArgs {
	args := new(cdpcmd.DebuggerContinueToLocationArgs)
	args.Location = location
	return args
}

func (d *debuggerDomain) StepOver(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerStepOver.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "StepOver", Err: err}
	}
	return
}

func (d *debuggerDomain) StepInto(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerStepInto.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "StepInto", Err: err}
	}
	return
}

func (d *debuggerDomain) StepOut(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerStepOut.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "StepOut", Err: err}
	}
	return
}

func (d *debuggerDomain) Pause(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerPause.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "Pause", Err: err}
	}
	return
}

func (d *debuggerDomain) ScheduleStepIntoAsync(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerScheduleStepIntoAsync.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "ScheduleStepIntoAsync", Err: err}
	}
	return
}

func (d *debuggerDomain) Resume(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerResume.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "Resume", Err: err}
	}
	return
}

func (d *debuggerDomain) SearchInContent(ctx context.Context, args *cdpcmd.DebuggerSearchInContentArgs) (reply *cdpcmd.DebuggerSearchInContentReply, err error) {
	reply = new(cdpcmd.DebuggerSearchInContentReply)

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSearchInContent.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SearchInContent", Err: err}
	}
	return
}

// NewDebuggerSearchInContentArgs initializes the arguments for SearchInContent.
func NewDebuggerSearchInContentArgs(scriptID cdptype.RuntimeScriptID, query string) *cdpcmd.DebuggerSearchInContentArgs {
	args := new(cdpcmd.DebuggerSearchInContentArgs)
	args.ScriptID = scriptID
	args.Query = query
	return args
}

func (d *debuggerDomain) SetScriptSource(ctx context.Context, args *cdpcmd.DebuggerSetScriptSourceArgs) (reply *cdpcmd.DebuggerSetScriptSourceReply, err error) {
	reply = new(cdpcmd.DebuggerSetScriptSourceReply)

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetScriptSource.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetScriptSource", Err: err}
	}
	return
}

// NewDebuggerSetScriptSourceArgs initializes the arguments for SetScriptSource.
func NewDebuggerSetScriptSourceArgs(scriptID cdptype.RuntimeScriptID, scriptSource string) *cdpcmd.DebuggerSetScriptSourceArgs {
	args := new(cdpcmd.DebuggerSetScriptSourceArgs)
	args.ScriptID = scriptID
	args.ScriptSource = scriptSource
	return args
}

func (d *debuggerDomain) RestartFrame(ctx context.Context, args *cdpcmd.DebuggerRestartFrameArgs) (reply *cdpcmd.DebuggerRestartFrameReply, err error) {
	reply = new(cdpcmd.DebuggerRestartFrameReply)

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerRestartFrame.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "RestartFrame", Err: err}
	}
	return
}

// NewDebuggerRestartFrameArgs initializes the arguments for RestartFrame.
func NewDebuggerRestartFrameArgs(callFrameID cdptype.DebuggerCallFrameID) *cdpcmd.DebuggerRestartFrameArgs {
	args := new(cdpcmd.DebuggerRestartFrameArgs)
	args.CallFrameID = callFrameID
	return args
}

func (d *debuggerDomain) GetScriptSource(ctx context.Context, args *cdpcmd.DebuggerGetScriptSourceArgs) (reply *cdpcmd.DebuggerGetScriptSourceReply, err error) {
	reply = new(cdpcmd.DebuggerGetScriptSourceReply)

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerGetScriptSource.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "GetScriptSource", Err: err}
	}
	return
}

// NewDebuggerGetScriptSourceArgs initializes the arguments for GetScriptSource.
func NewDebuggerGetScriptSourceArgs(scriptID cdptype.RuntimeScriptID) *cdpcmd.DebuggerGetScriptSourceArgs {
	args := new(cdpcmd.DebuggerGetScriptSourceArgs)
	args.ScriptID = scriptID
	return args
}

func (d *debuggerDomain) SetPauseOnExceptions(ctx context.Context, args *cdpcmd.DebuggerSetPauseOnExceptionsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetPauseOnExceptions.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetPauseOnExceptions", Err: err}
	}
	return
}

// NewDebuggerSetPauseOnExceptionsArgs initializes the arguments for SetPauseOnExceptions.
func NewDebuggerSetPauseOnExceptionsArgs(state string) *cdpcmd.DebuggerSetPauseOnExceptionsArgs {
	args := new(cdpcmd.DebuggerSetPauseOnExceptionsArgs)
	args.State = state
	return args
}

func (d *debuggerDomain) EvaluateOnCallFrame(ctx context.Context, args *cdpcmd.DebuggerEvaluateOnCallFrameArgs) (reply *cdpcmd.DebuggerEvaluateOnCallFrameReply, err error) {
	reply = new(cdpcmd.DebuggerEvaluateOnCallFrameReply)

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerEvaluateOnCallFrame.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "EvaluateOnCallFrame", Err: err}
	}
	return
}

// NewDebuggerEvaluateOnCallFrameArgs initializes the arguments for EvaluateOnCallFrame.
func NewDebuggerEvaluateOnCallFrameArgs(callFrameID cdptype.DebuggerCallFrameID, expression string) *cdpcmd.DebuggerEvaluateOnCallFrameArgs {
	args := new(cdpcmd.DebuggerEvaluateOnCallFrameArgs)
	args.CallFrameID = callFrameID
	args.Expression = expression
	return args
}

func (d *debuggerDomain) SetVariableValue(ctx context.Context, args *cdpcmd.DebuggerSetVariableValueArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetVariableValue.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetVariableValue", Err: err}
	}
	return
}

// NewDebuggerSetVariableValueArgs initializes the arguments for SetVariableValue.
func NewDebuggerSetVariableValueArgs(scopeNumber int, variableName string, newValue cdptype.RuntimeCallArgument, callFrameID cdptype.DebuggerCallFrameID) *cdpcmd.DebuggerSetVariableValueArgs {
	args := new(cdpcmd.DebuggerSetVariableValueArgs)
	args.ScopeNumber = scopeNumber
	args.VariableName = variableName
	args.NewValue = newValue
	args.CallFrameID = callFrameID
	return args
}

func (d *debuggerDomain) SetAsyncCallStackDepth(ctx context.Context, args *cdpcmd.DebuggerSetAsyncCallStackDepthArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetAsyncCallStackDepth.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetAsyncCallStackDepth", Err: err}
	}
	return
}

// NewDebuggerSetAsyncCallStackDepthArgs initializes the arguments for SetAsyncCallStackDepth.
func NewDebuggerSetAsyncCallStackDepthArgs(maxDepth int) *cdpcmd.DebuggerSetAsyncCallStackDepthArgs {
	args := new(cdpcmd.DebuggerSetAsyncCallStackDepthArgs)
	args.MaxDepth = maxDepth
	return args
}

func (d *debuggerDomain) SetBlackboxPatterns(ctx context.Context, args *cdpcmd.DebuggerSetBlackboxPatternsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBlackboxPatterns.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetBlackboxPatterns", Err: err}
	}
	return
}

// NewDebuggerSetBlackboxPatternsArgs initializes the arguments for SetBlackboxPatterns.
func NewDebuggerSetBlackboxPatternsArgs(patterns []string) *cdpcmd.DebuggerSetBlackboxPatternsArgs {
	args := new(cdpcmd.DebuggerSetBlackboxPatternsArgs)
	args.Patterns = patterns
	return args
}

func (d *debuggerDomain) SetBlackboxedRanges(ctx context.Context, args *cdpcmd.DebuggerSetBlackboxedRangesArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBlackboxedRanges.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Debugger", Op: "SetBlackboxedRanges", Err: err}
	}
	return
}

// NewDebuggerSetBlackboxedRangesArgs initializes the arguments for SetBlackboxedRanges.
func NewDebuggerSetBlackboxedRangesArgs(scriptID cdptype.RuntimeScriptID, positions []cdptype.DebuggerScriptPosition) *cdpcmd.DebuggerSetBlackboxedRangesArgs {
	args := new(cdpcmd.DebuggerSetBlackboxedRangesArgs)
	args.ScriptID = scriptID
	args.Positions = positions
	return args
}

func (d *debuggerDomain) ScriptParsed(ctx context.Context) (cdpevent.DebuggerScriptParsedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerScriptParsed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &debuggerScriptParsedClient{Stream: s}, nil
}

// debuggerScriptParsedClient implements DebuggerScriptParsedClient.
type debuggerScriptParsedClient struct{ rpcc.Stream }

func (c *debuggerScriptParsedClient) Recv() (*cdpevent.DebuggerScriptParsedReply, error) {
	event := new(cdpevent.DebuggerScriptParsedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Debugger", Op: "ScriptParsed Recv", Err: err}
	}
	return event, nil
}

func (d *debuggerDomain) ScriptFailedToParse(ctx context.Context) (cdpevent.DebuggerScriptFailedToParseClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerScriptFailedToParse.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &debuggerScriptFailedToParseClient{Stream: s}, nil
}

// debuggerScriptFailedToParseClient implements DebuggerScriptFailedToParseClient.
type debuggerScriptFailedToParseClient struct{ rpcc.Stream }

func (c *debuggerScriptFailedToParseClient) Recv() (*cdpevent.DebuggerScriptFailedToParseReply, error) {
	event := new(cdpevent.DebuggerScriptFailedToParseReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Debugger", Op: "ScriptFailedToParse Recv", Err: err}
	}
	return event, nil
}

func (d *debuggerDomain) BreakpointResolved(ctx context.Context) (cdpevent.DebuggerBreakpointResolvedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerBreakpointResolved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &debuggerBreakpointResolvedClient{Stream: s}, nil
}

// debuggerBreakpointResolvedClient implements DebuggerBreakpointResolvedClient.
type debuggerBreakpointResolvedClient struct{ rpcc.Stream }

func (c *debuggerBreakpointResolvedClient) Recv() (*cdpevent.DebuggerBreakpointResolvedReply, error) {
	event := new(cdpevent.DebuggerBreakpointResolvedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Debugger", Op: "BreakpointResolved Recv", Err: err}
	}
	return event, nil
}

func (d *debuggerDomain) Paused(ctx context.Context) (cdpevent.DebuggerPausedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerPaused.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &debuggerPausedClient{Stream: s}, nil
}

// debuggerPausedClient implements DebuggerPausedClient.
type debuggerPausedClient struct{ rpcc.Stream }

func (c *debuggerPausedClient) Recv() (*cdpevent.DebuggerPausedReply, error) {
	event := new(cdpevent.DebuggerPausedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Debugger", Op: "Paused Recv", Err: err}
	}
	return event, nil
}

func (d *debuggerDomain) Resumed(ctx context.Context) (cdpevent.DebuggerResumedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerResumed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &debuggerResumedClient{Stream: s}, nil
}

// debuggerResumedClient implements DebuggerResumedClient.
type debuggerResumedClient struct{ rpcc.Stream }

func (c *debuggerResumedClient) Recv() (*cdpevent.DebuggerResumedReply, error) {
	event := new(cdpevent.DebuggerResumedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Debugger", Op: "Resumed Recv", Err: err}
	}
	return event, nil
}

// The DeviceOrientation domain.
type DeviceOrientation interface {
	// Command SetDeviceOrientationOverride
	//
	// Overrides the Device Orientation.
	SetDeviceOrientationOverride(context.Context, *cdpcmd.DeviceOrientationSetDeviceOrientationOverrideArgs) error

	// Command ClearDeviceOrientationOverride
	//
	// Clears the overridden Device Orientation.
	ClearDeviceOrientationOverride(context.Context) error
}

// deviceorientationDomain implements the DeviceOrientation domain.
type deviceorientationDomain struct{ conn *rpcc.Conn }

func (d *deviceorientationDomain) SetDeviceOrientationOverride(ctx context.Context, args *cdpcmd.DeviceOrientationSetDeviceOrientationOverrideArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DeviceOrientationSetDeviceOrientationOverride.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DeviceOrientation", Op: "SetDeviceOrientationOverride", Err: err}
	}
	return
}

// NewDeviceOrientationSetDeviceOrientationOverrideArgs initializes the arguments for SetDeviceOrientationOverride.
func NewDeviceOrientationSetDeviceOrientationOverrideArgs(alpha float64, beta float64, gamma float64) *cdpcmd.DeviceOrientationSetDeviceOrientationOverrideArgs {
	args := new(cdpcmd.DeviceOrientationSetDeviceOrientationOverrideArgs)
	args.Alpha = alpha
	args.Beta = beta
	args.Gamma = gamma
	return args
}

func (d *deviceorientationDomain) ClearDeviceOrientationOverride(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.DeviceOrientationClearDeviceOrientationOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "DeviceOrientation", Op: "ClearDeviceOrientationOverride", Err: err}
	}
	return
}

// The Emulation domain. This domain emulates different environments for the page.
type Emulation interface {
	// Command SetDeviceMetricsOverride
	//
	// Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).
	SetDeviceMetricsOverride(context.Context, *cdpcmd.EmulationSetDeviceMetricsOverrideArgs) error

	// Command ClearDeviceMetricsOverride
	//
	// Clears the overriden device metrics.
	ClearDeviceMetricsOverride(context.Context) error

	// Command ForceViewport
	//
	// Overrides the visible area of the page. The change is hidden from the page, i.e. the observable scroll position and page scale does not change. In effect, the command moves the specified area of the page into the top-left corner of the frame.
	ForceViewport(context.Context, *cdpcmd.EmulationForceViewportArgs) error

	// Command ResetViewport
	//
	// Resets the visible area of the page to the original viewport, undoing any effects of the forceViewport command.
	ResetViewport(context.Context) error

	// Command ResetPageScaleFactor
	//
	// Requests that page scale factor is reset to initial values.
	ResetPageScaleFactor(context.Context) error

	// Command SetPageScaleFactor
	//
	// Sets a specified page scale factor.
	SetPageScaleFactor(context.Context, *cdpcmd.EmulationSetPageScaleFactorArgs) error

	// Command SetVisibleSize
	//
	// Resizes the frame/viewport of the page. Note that this does not affect the frame's container (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported on Android.
	SetVisibleSize(context.Context, *cdpcmd.EmulationSetVisibleSizeArgs) error

	// Command SetScriptExecutionDisabled
	//
	// Switches script execution in the page.
	SetScriptExecutionDisabled(context.Context, *cdpcmd.EmulationSetScriptExecutionDisabledArgs) error

	// Command SetGeolocationOverride
	//
	// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.
	SetGeolocationOverride(context.Context, *cdpcmd.EmulationSetGeolocationOverrideArgs) error

	// Command ClearGeolocationOverride
	//
	// Clears the overriden Geolocation Position and Error.
	ClearGeolocationOverride(context.Context) error

	// Command SetTouchEmulationEnabled
	//
	// Toggles mouse event-based touch event emulation.
	SetTouchEmulationEnabled(context.Context, *cdpcmd.EmulationSetTouchEmulationEnabledArgs) error

	// Command SetEmulatedMedia
	//
	// Emulates the given media for CSS media queries.
	SetEmulatedMedia(context.Context, *cdpcmd.EmulationSetEmulatedMediaArgs) error

	// Command SetCPUThrottlingRate
	//
	// Enables CPU throttling to emulate slow CPUs.
	SetCPUThrottlingRate(context.Context, *cdpcmd.EmulationSetCPUThrottlingRateArgs) error

	// Command CanEmulate
	//
	// Tells whether emulation is supported.
	CanEmulate(context.Context) (*cdpcmd.EmulationCanEmulateReply, error)

	// Command SetVirtualTimePolicy
	//
	// Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets the current virtual time policy.  Note this supersedes any previous time budget.
	SetVirtualTimePolicy(context.Context, *cdpcmd.EmulationSetVirtualTimePolicyArgs) error

	// Command SetDefaultBackgroundColorOverride
	//
	// Sets or clears an override of the default background color of the frame. This override is used if the content does not specify one.
	SetDefaultBackgroundColorOverride(context.Context, *cdpcmd.EmulationSetDefaultBackgroundColorOverrideArgs) error

	// Event VirtualTimeBudgetExpired
	//
	// Notification sent after the virual time budget for the current VirtualTimePolicy has run out.
	VirtualTimeBudgetExpired(context.Context) (cdpevent.EmulationVirtualTimeBudgetExpiredClient, error)
}

// emulationDomain implements the Emulation domain.
type emulationDomain struct{ conn *rpcc.Conn }

func (d *emulationDomain) SetDeviceMetricsOverride(ctx context.Context, args *cdpcmd.EmulationSetDeviceMetricsOverrideArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetDeviceMetricsOverride.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetDeviceMetricsOverride", Err: err}
	}
	return
}

// NewEmulationSetDeviceMetricsOverrideArgs initializes the arguments for SetDeviceMetricsOverride.
func NewEmulationSetDeviceMetricsOverrideArgs(width int, height int, deviceScaleFactor float64, mobile bool, fitWindow bool) *cdpcmd.EmulationSetDeviceMetricsOverrideArgs {
	args := new(cdpcmd.EmulationSetDeviceMetricsOverrideArgs)
	args.Width = width
	args.Height = height
	args.DeviceScaleFactor = deviceScaleFactor
	args.Mobile = mobile
	args.FitWindow = fitWindow
	return args
}

func (d *emulationDomain) ClearDeviceMetricsOverride(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationClearDeviceMetricsOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "ClearDeviceMetricsOverride", Err: err}
	}
	return
}

func (d *emulationDomain) ForceViewport(ctx context.Context, args *cdpcmd.EmulationForceViewportArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationForceViewport.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "ForceViewport", Err: err}
	}
	return
}

// NewEmulationForceViewportArgs initializes the arguments for ForceViewport.
func NewEmulationForceViewportArgs(x float64, y float64, scale float64) *cdpcmd.EmulationForceViewportArgs {
	args := new(cdpcmd.EmulationForceViewportArgs)
	args.X = x
	args.Y = y
	args.Scale = scale
	return args
}

func (d *emulationDomain) ResetViewport(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationResetViewport.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "ResetViewport", Err: err}
	}
	return
}

func (d *emulationDomain) ResetPageScaleFactor(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationResetPageScaleFactor.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "ResetPageScaleFactor", Err: err}
	}
	return
}

func (d *emulationDomain) SetPageScaleFactor(ctx context.Context, args *cdpcmd.EmulationSetPageScaleFactorArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetPageScaleFactor.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetPageScaleFactor", Err: err}
	}
	return
}

// NewEmulationSetPageScaleFactorArgs initializes the arguments for SetPageScaleFactor.
func NewEmulationSetPageScaleFactorArgs(pageScaleFactor float64) *cdpcmd.EmulationSetPageScaleFactorArgs {
	args := new(cdpcmd.EmulationSetPageScaleFactorArgs)
	args.PageScaleFactor = pageScaleFactor
	return args
}

func (d *emulationDomain) SetVisibleSize(ctx context.Context, args *cdpcmd.EmulationSetVisibleSizeArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetVisibleSize.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetVisibleSize", Err: err}
	}
	return
}

// NewEmulationSetVisibleSizeArgs initializes the arguments for SetVisibleSize.
func NewEmulationSetVisibleSizeArgs(width int, height int) *cdpcmd.EmulationSetVisibleSizeArgs {
	args := new(cdpcmd.EmulationSetVisibleSizeArgs)
	args.Width = width
	args.Height = height
	return args
}

func (d *emulationDomain) SetScriptExecutionDisabled(ctx context.Context, args *cdpcmd.EmulationSetScriptExecutionDisabledArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetScriptExecutionDisabled.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetScriptExecutionDisabled", Err: err}
	}
	return
}

// NewEmulationSetScriptExecutionDisabledArgs initializes the arguments for SetScriptExecutionDisabled.
func NewEmulationSetScriptExecutionDisabledArgs(value bool) *cdpcmd.EmulationSetScriptExecutionDisabledArgs {
	args := new(cdpcmd.EmulationSetScriptExecutionDisabledArgs)
	args.Value = value
	return args
}

func (d *emulationDomain) SetGeolocationOverride(ctx context.Context, args *cdpcmd.EmulationSetGeolocationOverrideArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetGeolocationOverride.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetGeolocationOverride", Err: err}
	}
	return
}

// NewEmulationSetGeolocationOverrideArgs initializes the arguments for SetGeolocationOverride.
func NewEmulationSetGeolocationOverrideArgs() *cdpcmd.EmulationSetGeolocationOverrideArgs {
	args := new(cdpcmd.EmulationSetGeolocationOverrideArgs)

	return args
}

func (d *emulationDomain) ClearGeolocationOverride(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationClearGeolocationOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "ClearGeolocationOverride", Err: err}
	}
	return
}

func (d *emulationDomain) SetTouchEmulationEnabled(ctx context.Context, args *cdpcmd.EmulationSetTouchEmulationEnabledArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetTouchEmulationEnabled.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetTouchEmulationEnabled", Err: err}
	}
	return
}

// NewEmulationSetTouchEmulationEnabledArgs initializes the arguments for SetTouchEmulationEnabled.
func NewEmulationSetTouchEmulationEnabledArgs(enabled bool) *cdpcmd.EmulationSetTouchEmulationEnabledArgs {
	args := new(cdpcmd.EmulationSetTouchEmulationEnabledArgs)
	args.Enabled = enabled
	return args
}

func (d *emulationDomain) SetEmulatedMedia(ctx context.Context, args *cdpcmd.EmulationSetEmulatedMediaArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetEmulatedMedia.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetEmulatedMedia", Err: err}
	}
	return
}

// NewEmulationSetEmulatedMediaArgs initializes the arguments for SetEmulatedMedia.
func NewEmulationSetEmulatedMediaArgs(media string) *cdpcmd.EmulationSetEmulatedMediaArgs {
	args := new(cdpcmd.EmulationSetEmulatedMediaArgs)
	args.Media = media
	return args
}

func (d *emulationDomain) SetCPUThrottlingRate(ctx context.Context, args *cdpcmd.EmulationSetCPUThrottlingRateArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetCPUThrottlingRate.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetCPUThrottlingRate", Err: err}
	}
	return
}

// NewEmulationSetCPUThrottlingRateArgs initializes the arguments for SetCPUThrottlingRate.
func NewEmulationSetCPUThrottlingRateArgs(rate float64) *cdpcmd.EmulationSetCPUThrottlingRateArgs {
	args := new(cdpcmd.EmulationSetCPUThrottlingRateArgs)
	args.Rate = rate
	return args
}

func (d *emulationDomain) CanEmulate(ctx context.Context) (reply *cdpcmd.EmulationCanEmulateReply, err error) {
	reply = new(cdpcmd.EmulationCanEmulateReply)

	err = rpcc.Invoke(ctx, cdpcmd.EmulationCanEmulate.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "CanEmulate", Err: err}
	}
	return
}

func (d *emulationDomain) SetVirtualTimePolicy(ctx context.Context, args *cdpcmd.EmulationSetVirtualTimePolicyArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetVirtualTimePolicy.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetVirtualTimePolicy", Err: err}
	}
	return
}

// NewEmulationSetVirtualTimePolicyArgs initializes the arguments for SetVirtualTimePolicy.
func NewEmulationSetVirtualTimePolicyArgs(policy cdptype.EmulationVirtualTimePolicy) *cdpcmd.EmulationSetVirtualTimePolicyArgs {
	args := new(cdpcmd.EmulationSetVirtualTimePolicyArgs)
	args.Policy = policy
	return args
}

func (d *emulationDomain) SetDefaultBackgroundColorOverride(ctx context.Context, args *cdpcmd.EmulationSetDefaultBackgroundColorOverrideArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.EmulationSetDefaultBackgroundColorOverride.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Emulation", Op: "SetDefaultBackgroundColorOverride", Err: err}
	}
	return
}

// NewEmulationSetDefaultBackgroundColorOverrideArgs initializes the arguments for SetDefaultBackgroundColorOverride.
func NewEmulationSetDefaultBackgroundColorOverrideArgs() *cdpcmd.EmulationSetDefaultBackgroundColorOverrideArgs {
	args := new(cdpcmd.EmulationSetDefaultBackgroundColorOverrideArgs)

	return args
}

func (d *emulationDomain) VirtualTimeBudgetExpired(ctx context.Context) (cdpevent.EmulationVirtualTimeBudgetExpiredClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.EmulationVirtualTimeBudgetExpired.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &emulationVirtualTimeBudgetExpiredClient{Stream: s}, nil
}

// emulationVirtualTimeBudgetExpiredClient implements EmulationVirtualTimeBudgetExpiredClient.
type emulationVirtualTimeBudgetExpiredClient struct{ rpcc.Stream }

func (c *emulationVirtualTimeBudgetExpiredClient) Recv() (*cdpevent.EmulationVirtualTimeBudgetExpiredReply, error) {
	event := new(cdpevent.EmulationVirtualTimeBudgetExpiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Emulation", Op: "VirtualTimeBudgetExpired Recv", Err: err}
	}
	return event, nil
}

// The HeapProfiler domain.
type HeapProfiler interface {
	// Command Enable
	//
	//
	Enable(context.Context) error

	// Command Disable
	//
	//
	Disable(context.Context) error

	// Command StartTrackingHeapObjects
	//
	//
	StartTrackingHeapObjects(context.Context, *cdpcmd.HeapProfilerStartTrackingHeapObjectsArgs) error

	// Command StopTrackingHeapObjects
	//
	//
	StopTrackingHeapObjects(context.Context, *cdpcmd.HeapProfilerStopTrackingHeapObjectsArgs) error

	// Command TakeHeapSnapshot
	//
	//
	TakeHeapSnapshot(context.Context, *cdpcmd.HeapProfilerTakeHeapSnapshotArgs) error

	// Command CollectGarbage
	//
	//
	CollectGarbage(context.Context) error

	// Command GetObjectByHeapObjectID
	//
	//
	GetObjectByHeapObjectID(context.Context, *cdpcmd.HeapProfilerGetObjectByHeapObjectIDArgs) (*cdpcmd.HeapProfilerGetObjectByHeapObjectIDReply, error)

	// Command AddInspectedHeapObject
	//
	// Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
	AddInspectedHeapObject(context.Context, *cdpcmd.HeapProfilerAddInspectedHeapObjectArgs) error

	// Command GetHeapObjectID
	//
	//
	GetHeapObjectID(context.Context, *cdpcmd.HeapProfilerGetHeapObjectIDArgs) (*cdpcmd.HeapProfilerGetHeapObjectIDReply, error)

	// Command StartSampling
	//
	//
	StartSampling(context.Context, *cdpcmd.HeapProfilerStartSamplingArgs) error

	// Command StopSampling
	//
	//
	StopSampling(context.Context) (*cdpcmd.HeapProfilerStopSamplingReply, error)

	// Event AddHeapSnapshotChunk
	//
	//
	AddHeapSnapshotChunk(context.Context) (cdpevent.HeapProfilerAddHeapSnapshotChunkClient, error)

	// Event ResetProfiles
	//
	//
	ResetProfiles(context.Context) (cdpevent.HeapProfilerResetProfilesClient, error)

	// Event ReportHeapSnapshotProgress
	//
	//
	ReportHeapSnapshotProgress(context.Context) (cdpevent.HeapProfilerReportHeapSnapshotProgressClient, error)

	// Event LastSeenObjectID
	//
	// If heap objects tracking has been started then backend regulary sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
	LastSeenObjectID(context.Context) (cdpevent.HeapProfilerLastSeenObjectIDClient, error)

	// Event HeapStatsUpdate
	//
	// If heap objects tracking has been started then backend may send update for one or more fragments
	HeapStatsUpdate(context.Context) (cdpevent.HeapProfilerHeapStatsUpdateClient, error)
}

// heapprofilerDomain implements the HeapProfiler domain.
type heapprofilerDomain struct{ conn *rpcc.Conn }

func (d *heapprofilerDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "Enable", Err: err}
	}
	return
}

func (d *heapprofilerDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "Disable", Err: err}
	}
	return
}

func (d *heapprofilerDomain) StartTrackingHeapObjects(ctx context.Context, args *cdpcmd.HeapProfilerStartTrackingHeapObjectsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStartTrackingHeapObjects.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "StartTrackingHeapObjects", Err: err}
	}
	return
}

// NewHeapProfilerStartTrackingHeapObjectsArgs initializes the arguments for StartTrackingHeapObjects.
func NewHeapProfilerStartTrackingHeapObjectsArgs() *cdpcmd.HeapProfilerStartTrackingHeapObjectsArgs {
	args := new(cdpcmd.HeapProfilerStartTrackingHeapObjectsArgs)

	return args
}

func (d *heapprofilerDomain) StopTrackingHeapObjects(ctx context.Context, args *cdpcmd.HeapProfilerStopTrackingHeapObjectsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStopTrackingHeapObjects.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "StopTrackingHeapObjects", Err: err}
	}
	return
}

// NewHeapProfilerStopTrackingHeapObjectsArgs initializes the arguments for StopTrackingHeapObjects.
func NewHeapProfilerStopTrackingHeapObjectsArgs() *cdpcmd.HeapProfilerStopTrackingHeapObjectsArgs {
	args := new(cdpcmd.HeapProfilerStopTrackingHeapObjectsArgs)

	return args
}

func (d *heapprofilerDomain) TakeHeapSnapshot(ctx context.Context, args *cdpcmd.HeapProfilerTakeHeapSnapshotArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerTakeHeapSnapshot.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "TakeHeapSnapshot", Err: err}
	}
	return
}

// NewHeapProfilerTakeHeapSnapshotArgs initializes the arguments for TakeHeapSnapshot.
func NewHeapProfilerTakeHeapSnapshotArgs() *cdpcmd.HeapProfilerTakeHeapSnapshotArgs {
	args := new(cdpcmd.HeapProfilerTakeHeapSnapshotArgs)

	return args
}

func (d *heapprofilerDomain) CollectGarbage(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerCollectGarbage.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "CollectGarbage", Err: err}
	}
	return
}

func (d *heapprofilerDomain) GetObjectByHeapObjectID(ctx context.Context, args *cdpcmd.HeapProfilerGetObjectByHeapObjectIDArgs) (reply *cdpcmd.HeapProfilerGetObjectByHeapObjectIDReply, err error) {
	reply = new(cdpcmd.HeapProfilerGetObjectByHeapObjectIDReply)

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerGetObjectByHeapObjectID.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "GetObjectByHeapObjectID", Err: err}
	}
	return
}

// NewHeapProfilerGetObjectByHeapObjectIDArgs initializes the arguments for GetObjectByHeapObjectID.
func NewHeapProfilerGetObjectByHeapObjectIDArgs(objectID cdptype.HeapProfilerHeapSnapshotObjectID) *cdpcmd.HeapProfilerGetObjectByHeapObjectIDArgs {
	args := new(cdpcmd.HeapProfilerGetObjectByHeapObjectIDArgs)
	args.ObjectID = objectID
	return args
}

func (d *heapprofilerDomain) AddInspectedHeapObject(ctx context.Context, args *cdpcmd.HeapProfilerAddInspectedHeapObjectArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerAddInspectedHeapObject.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "AddInspectedHeapObject", Err: err}
	}
	return
}

// NewHeapProfilerAddInspectedHeapObjectArgs initializes the arguments for AddInspectedHeapObject.
func NewHeapProfilerAddInspectedHeapObjectArgs(heapObjectID cdptype.HeapProfilerHeapSnapshotObjectID) *cdpcmd.HeapProfilerAddInspectedHeapObjectArgs {
	args := new(cdpcmd.HeapProfilerAddInspectedHeapObjectArgs)
	args.HeapObjectID = heapObjectID
	return args
}

func (d *heapprofilerDomain) GetHeapObjectID(ctx context.Context, args *cdpcmd.HeapProfilerGetHeapObjectIDArgs) (reply *cdpcmd.HeapProfilerGetHeapObjectIDReply, err error) {
	reply = new(cdpcmd.HeapProfilerGetHeapObjectIDReply)

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerGetHeapObjectID.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "GetHeapObjectID", Err: err}
	}
	return
}

// NewHeapProfilerGetHeapObjectIDArgs initializes the arguments for GetHeapObjectID.
func NewHeapProfilerGetHeapObjectIDArgs(objectID cdptype.RuntimeRemoteObjectID) *cdpcmd.HeapProfilerGetHeapObjectIDArgs {
	args := new(cdpcmd.HeapProfilerGetHeapObjectIDArgs)
	args.ObjectID = objectID
	return args
}

func (d *heapprofilerDomain) StartSampling(ctx context.Context, args *cdpcmd.HeapProfilerStartSamplingArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStartSampling.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "StartSampling", Err: err}
	}
	return
}

// NewHeapProfilerStartSamplingArgs initializes the arguments for StartSampling.
func NewHeapProfilerStartSamplingArgs() *cdpcmd.HeapProfilerStartSamplingArgs {
	args := new(cdpcmd.HeapProfilerStartSamplingArgs)

	return args
}

func (d *heapprofilerDomain) StopSampling(ctx context.Context) (reply *cdpcmd.HeapProfilerStopSamplingReply, err error) {
	reply = new(cdpcmd.HeapProfilerStopSamplingReply)

	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStopSampling.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "HeapProfiler", Op: "StopSampling", Err: err}
	}
	return
}

func (d *heapprofilerDomain) AddHeapSnapshotChunk(ctx context.Context) (cdpevent.HeapProfilerAddHeapSnapshotChunkClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerAddHeapSnapshotChunk.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &heapprofilerAddHeapSnapshotChunkClient{Stream: s}, nil
}

// heapprofilerAddHeapSnapshotChunkClient implements HeapProfilerAddHeapSnapshotChunkClient.
type heapprofilerAddHeapSnapshotChunkClient struct{ rpcc.Stream }

func (c *heapprofilerAddHeapSnapshotChunkClient) Recv() (*cdpevent.HeapProfilerAddHeapSnapshotChunkReply, error) {
	event := new(cdpevent.HeapProfilerAddHeapSnapshotChunkReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "HeapProfiler", Op: "AddHeapSnapshotChunk Recv", Err: err}
	}
	return event, nil
}

func (d *heapprofilerDomain) ResetProfiles(ctx context.Context) (cdpevent.HeapProfilerResetProfilesClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerResetProfiles.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &heapprofilerResetProfilesClient{Stream: s}, nil
}

// heapprofilerResetProfilesClient implements HeapProfilerResetProfilesClient.
type heapprofilerResetProfilesClient struct{ rpcc.Stream }

func (c *heapprofilerResetProfilesClient) Recv() (*cdpevent.HeapProfilerResetProfilesReply, error) {
	event := new(cdpevent.HeapProfilerResetProfilesReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "HeapProfiler", Op: "ResetProfiles Recv", Err: err}
	}
	return event, nil
}

func (d *heapprofilerDomain) ReportHeapSnapshotProgress(ctx context.Context) (cdpevent.HeapProfilerReportHeapSnapshotProgressClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerReportHeapSnapshotProgress.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &heapprofilerReportHeapSnapshotProgressClient{Stream: s}, nil
}

// heapprofilerReportHeapSnapshotProgressClient implements HeapProfilerReportHeapSnapshotProgressClient.
type heapprofilerReportHeapSnapshotProgressClient struct{ rpcc.Stream }

func (c *heapprofilerReportHeapSnapshotProgressClient) Recv() (*cdpevent.HeapProfilerReportHeapSnapshotProgressReply, error) {
	event := new(cdpevent.HeapProfilerReportHeapSnapshotProgressReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "HeapProfiler", Op: "ReportHeapSnapshotProgress Recv", Err: err}
	}
	return event, nil
}

func (d *heapprofilerDomain) LastSeenObjectID(ctx context.Context) (cdpevent.HeapProfilerLastSeenObjectIDClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerLastSeenObjectID.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &heapprofilerLastSeenObjectIDClient{Stream: s}, nil
}

// heapprofilerLastSeenObjectIDClient implements HeapProfilerLastSeenObjectIDClient.
type heapprofilerLastSeenObjectIDClient struct{ rpcc.Stream }

func (c *heapprofilerLastSeenObjectIDClient) Recv() (*cdpevent.HeapProfilerLastSeenObjectIDReply, error) {
	event := new(cdpevent.HeapProfilerLastSeenObjectIDReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "HeapProfiler", Op: "LastSeenObjectID Recv", Err: err}
	}
	return event, nil
}

func (d *heapprofilerDomain) HeapStatsUpdate(ctx context.Context) (cdpevent.HeapProfilerHeapStatsUpdateClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerHeapStatsUpdate.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &heapprofilerHeapStatsUpdateClient{Stream: s}, nil
}

// heapprofilerHeapStatsUpdateClient implements HeapProfilerHeapStatsUpdateClient.
type heapprofilerHeapStatsUpdateClient struct{ rpcc.Stream }

func (c *heapprofilerHeapStatsUpdateClient) Recv() (*cdpevent.HeapProfilerHeapStatsUpdateReply, error) {
	event := new(cdpevent.HeapProfilerHeapStatsUpdateReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "HeapProfiler", Op: "HeapStatsUpdate Recv", Err: err}
	}
	return event, nil
}

// The IO domain. Input/Output operations for streams produced by DevTools.
type IO interface {
	// Command Read
	//
	// Read a chunk of the stream
	Read(context.Context, *cdpcmd.IOReadArgs) (*cdpcmd.IOReadReply, error)

	// Command Close
	//
	// Close the stream, discard any temporary backing storage.
	Close(context.Context, *cdpcmd.IOCloseArgs) error
}

// ioDomain implements the IO domain.
type ioDomain struct{ conn *rpcc.Conn }

func (d *ioDomain) Read(ctx context.Context, args *cdpcmd.IOReadArgs) (reply *cdpcmd.IOReadReply, err error) {
	reply = new(cdpcmd.IOReadReply)

	err = rpcc.Invoke(ctx, cdpcmd.IORead.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "IO", Op: "Read", Err: err}
	}
	return
}

// NewIOReadArgs initializes the arguments for Read.
func NewIOReadArgs(handle cdptype.IOStreamHandle) *cdpcmd.IOReadArgs {
	args := new(cdpcmd.IOReadArgs)
	args.Handle = handle
	return args
}

func (d *ioDomain) Close(ctx context.Context, args *cdpcmd.IOCloseArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.IOClose.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "IO", Op: "Close", Err: err}
	}
	return
}

// NewIOCloseArgs initializes the arguments for Close.
func NewIOCloseArgs(handle cdptype.IOStreamHandle) *cdpcmd.IOCloseArgs {
	args := new(cdpcmd.IOCloseArgs)
	args.Handle = handle
	return args
}

// The IndexedDB domain.
type IndexedDB interface {
	// Command Enable
	//
	// Enables events from backend.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables events from backend.
	Disable(context.Context) error

	// Command RequestDatabaseNames
	//
	// Requests database names for given security origin.
	RequestDatabaseNames(context.Context, *cdpcmd.IndexedDBRequestDatabaseNamesArgs) (*cdpcmd.IndexedDBRequestDatabaseNamesReply, error)

	// Command RequestDatabase
	//
	// Requests database with given name in given frame.
	RequestDatabase(context.Context, *cdpcmd.IndexedDBRequestDatabaseArgs) (*cdpcmd.IndexedDBRequestDatabaseReply, error)

	// Command RequestData
	//
	// Requests data from object store or index.
	RequestData(context.Context, *cdpcmd.IndexedDBRequestDataArgs) (*cdpcmd.IndexedDBRequestDataReply, error)

	// Command ClearObjectStore
	//
	// Clears all entries from an object store.
	ClearObjectStore(context.Context, *cdpcmd.IndexedDBClearObjectStoreArgs) error

	// Command DeleteDatabase
	//
	// Deletes a database.
	DeleteDatabase(context.Context, *cdpcmd.IndexedDBDeleteDatabaseArgs) error
}

// indexeddbDomain implements the IndexedDB domain.
type indexeddbDomain struct{ conn *rpcc.Conn }

func (d *indexeddbDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "IndexedDB", Op: "Enable", Err: err}
	}
	return
}

func (d *indexeddbDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "IndexedDB", Op: "Disable", Err: err}
	}
	return
}

func (d *indexeddbDomain) RequestDatabaseNames(ctx context.Context, args *cdpcmd.IndexedDBRequestDatabaseNamesArgs) (reply *cdpcmd.IndexedDBRequestDatabaseNamesReply, err error) {
	reply = new(cdpcmd.IndexedDBRequestDatabaseNamesReply)

	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestDatabaseNames.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "IndexedDB", Op: "RequestDatabaseNames", Err: err}
	}
	return
}

// NewIndexedDBRequestDatabaseNamesArgs initializes the arguments for RequestDatabaseNames.
func NewIndexedDBRequestDatabaseNamesArgs(securityOrigin string) *cdpcmd.IndexedDBRequestDatabaseNamesArgs {
	args := new(cdpcmd.IndexedDBRequestDatabaseNamesArgs)
	args.SecurityOrigin = securityOrigin
	return args
}

func (d *indexeddbDomain) RequestDatabase(ctx context.Context, args *cdpcmd.IndexedDBRequestDatabaseArgs) (reply *cdpcmd.IndexedDBRequestDatabaseReply, err error) {
	reply = new(cdpcmd.IndexedDBRequestDatabaseReply)

	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestDatabase.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "IndexedDB", Op: "RequestDatabase", Err: err}
	}
	return
}

// NewIndexedDBRequestDatabaseArgs initializes the arguments for RequestDatabase.
func NewIndexedDBRequestDatabaseArgs(securityOrigin string, databaseName string) *cdpcmd.IndexedDBRequestDatabaseArgs {
	args := new(cdpcmd.IndexedDBRequestDatabaseArgs)
	args.SecurityOrigin = securityOrigin
	args.DatabaseName = databaseName
	return args
}

func (d *indexeddbDomain) RequestData(ctx context.Context, args *cdpcmd.IndexedDBRequestDataArgs) (reply *cdpcmd.IndexedDBRequestDataReply, err error) {
	reply = new(cdpcmd.IndexedDBRequestDataReply)

	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestData.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "IndexedDB", Op: "RequestData", Err: err}
	}
	return
}

// NewIndexedDBRequestDataArgs initializes the arguments for RequestData.
func NewIndexedDBRequestDataArgs(securityOrigin string, databaseName string, objectStoreName string, indexName string, skipCount int, pageSize int) *cdpcmd.IndexedDBRequestDataArgs {
	args := new(cdpcmd.IndexedDBRequestDataArgs)
	args.SecurityOrigin = securityOrigin
	args.DatabaseName = databaseName
	args.ObjectStoreName = objectStoreName
	args.IndexName = indexName
	args.SkipCount = skipCount
	args.PageSize = pageSize
	return args
}

func (d *indexeddbDomain) ClearObjectStore(ctx context.Context, args *cdpcmd.IndexedDBClearObjectStoreArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBClearObjectStore.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "IndexedDB", Op: "ClearObjectStore", Err: err}
	}
	return
}

// NewIndexedDBClearObjectStoreArgs initializes the arguments for ClearObjectStore.
func NewIndexedDBClearObjectStoreArgs(securityOrigin string, databaseName string, objectStoreName string) *cdpcmd.IndexedDBClearObjectStoreArgs {
	args := new(cdpcmd.IndexedDBClearObjectStoreArgs)
	args.SecurityOrigin = securityOrigin
	args.DatabaseName = databaseName
	args.ObjectStoreName = objectStoreName
	return args
}

func (d *indexeddbDomain) DeleteDatabase(ctx context.Context, args *cdpcmd.IndexedDBDeleteDatabaseArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBDeleteDatabase.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "IndexedDB", Op: "DeleteDatabase", Err: err}
	}
	return
}

// NewIndexedDBDeleteDatabaseArgs initializes the arguments for DeleteDatabase.
func NewIndexedDBDeleteDatabaseArgs(securityOrigin string, databaseName string) *cdpcmd.IndexedDBDeleteDatabaseArgs {
	args := new(cdpcmd.IndexedDBDeleteDatabaseArgs)
	args.SecurityOrigin = securityOrigin
	args.DatabaseName = databaseName
	return args
}

// The Input domain.
type Input interface {
	// Command DispatchKeyEvent
	//
	// Dispatches a key event to the page.
	DispatchKeyEvent(context.Context, *cdpcmd.InputDispatchKeyEventArgs) error

	// Command DispatchMouseEvent
	//
	// Dispatches a mouse event to the page.
	DispatchMouseEvent(context.Context, *cdpcmd.InputDispatchMouseEventArgs) error

	// Command DispatchTouchEvent
	//
	// Dispatches a touch event to the page.
	DispatchTouchEvent(context.Context, *cdpcmd.InputDispatchTouchEventArgs) error

	// Command EmulateTouchFromMouseEvent
	//
	// Emulates touch event from the mouse event parameters.
	EmulateTouchFromMouseEvent(context.Context, *cdpcmd.InputEmulateTouchFromMouseEventArgs) error

	// Command SynthesizePinchGesture
	//
	// Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
	SynthesizePinchGesture(context.Context, *cdpcmd.InputSynthesizePinchGestureArgs) error

	// Command SynthesizeScrollGesture
	//
	// Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
	SynthesizeScrollGesture(context.Context, *cdpcmd.InputSynthesizeScrollGestureArgs) error

	// Command SynthesizeTapGesture
	//
	// Synthesizes a tap gesture over a time period by issuing appropriate touch events.
	SynthesizeTapGesture(context.Context, *cdpcmd.InputSynthesizeTapGestureArgs) error
}

// inputDomain implements the Input domain.
type inputDomain struct{ conn *rpcc.Conn }

func (d *inputDomain) DispatchKeyEvent(ctx context.Context, args *cdpcmd.InputDispatchKeyEventArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InputDispatchKeyEvent.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Input", Op: "DispatchKeyEvent", Err: err}
	}
	return
}

// NewInputDispatchKeyEventArgs initializes the arguments for DispatchKeyEvent.
func NewInputDispatchKeyEventArgs(typ string) *cdpcmd.InputDispatchKeyEventArgs {
	args := new(cdpcmd.InputDispatchKeyEventArgs)
	args.Type = typ
	return args
}

func (d *inputDomain) DispatchMouseEvent(ctx context.Context, args *cdpcmd.InputDispatchMouseEventArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InputDispatchMouseEvent.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Input", Op: "DispatchMouseEvent", Err: err}
	}
	return
}

// NewInputDispatchMouseEventArgs initializes the arguments for DispatchMouseEvent.
func NewInputDispatchMouseEventArgs(typ string, x int, y int) *cdpcmd.InputDispatchMouseEventArgs {
	args := new(cdpcmd.InputDispatchMouseEventArgs)
	args.Type = typ
	args.X = x
	args.Y = y
	return args
}

func (d *inputDomain) DispatchTouchEvent(ctx context.Context, args *cdpcmd.InputDispatchTouchEventArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InputDispatchTouchEvent.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Input", Op: "DispatchTouchEvent", Err: err}
	}
	return
}

// NewInputDispatchTouchEventArgs initializes the arguments for DispatchTouchEvent.
func NewInputDispatchTouchEventArgs(typ string, touchPoints []cdptype.InputTouchPoint) *cdpcmd.InputDispatchTouchEventArgs {
	args := new(cdpcmd.InputDispatchTouchEventArgs)
	args.Type = typ
	args.TouchPoints = touchPoints
	return args
}

func (d *inputDomain) EmulateTouchFromMouseEvent(ctx context.Context, args *cdpcmd.InputEmulateTouchFromMouseEventArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InputEmulateTouchFromMouseEvent.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Input", Op: "EmulateTouchFromMouseEvent", Err: err}
	}
	return
}

// NewInputEmulateTouchFromMouseEventArgs initializes the arguments for EmulateTouchFromMouseEvent.
func NewInputEmulateTouchFromMouseEventArgs(typ string, x int, y int, timestamp cdptype.Timestamp, button string) *cdpcmd.InputEmulateTouchFromMouseEventArgs {
	args := new(cdpcmd.InputEmulateTouchFromMouseEventArgs)
	args.Type = typ
	args.X = x
	args.Y = y
	args.Timestamp = timestamp
	args.Button = button
	return args
}

func (d *inputDomain) SynthesizePinchGesture(ctx context.Context, args *cdpcmd.InputSynthesizePinchGestureArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizePinchGesture.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Input", Op: "SynthesizePinchGesture", Err: err}
	}
	return
}

// NewInputSynthesizePinchGestureArgs initializes the arguments for SynthesizePinchGesture.
func NewInputSynthesizePinchGestureArgs(x int, y int, scaleFactor float64) *cdpcmd.InputSynthesizePinchGestureArgs {
	args := new(cdpcmd.InputSynthesizePinchGestureArgs)
	args.X = x
	args.Y = y
	args.ScaleFactor = scaleFactor
	return args
}

func (d *inputDomain) SynthesizeScrollGesture(ctx context.Context, args *cdpcmd.InputSynthesizeScrollGestureArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizeScrollGesture.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Input", Op: "SynthesizeScrollGesture", Err: err}
	}
	return
}

// NewInputSynthesizeScrollGestureArgs initializes the arguments for SynthesizeScrollGesture.
func NewInputSynthesizeScrollGestureArgs(x int, y int) *cdpcmd.InputSynthesizeScrollGestureArgs {
	args := new(cdpcmd.InputSynthesizeScrollGestureArgs)
	args.X = x
	args.Y = y
	return args
}

func (d *inputDomain) SynthesizeTapGesture(ctx context.Context, args *cdpcmd.InputSynthesizeTapGestureArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizeTapGesture.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Input", Op: "SynthesizeTapGesture", Err: err}
	}
	return
}

// NewInputSynthesizeTapGestureArgs initializes the arguments for SynthesizeTapGesture.
func NewInputSynthesizeTapGestureArgs(x int, y int) *cdpcmd.InputSynthesizeTapGestureArgs {
	args := new(cdpcmd.InputSynthesizeTapGestureArgs)
	args.X = x
	args.Y = y
	return args
}

// The Inspector domain.
type Inspector interface {
	// Command Enable
	//
	// Enables inspector domain notifications.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables inspector domain notifications.
	Disable(context.Context) error

	// Event Detached
	//
	// Fired when remote debugging connection is about to be terminated. Contains detach reason.
	Detached(context.Context) (cdpevent.InspectorDetachedClient, error)

	// Event TargetCrashed
	//
	// Fired when debugging target has crashed
	TargetCrashed(context.Context) (cdpevent.InspectorTargetCrashedClient, error)
}

// inspectorDomain implements the Inspector domain.
type inspectorDomain struct{ conn *rpcc.Conn }

func (d *inspectorDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InspectorEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Inspector", Op: "Enable", Err: err}
	}
	return
}

func (d *inspectorDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.InspectorDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Inspector", Op: "Disable", Err: err}
	}
	return
}

func (d *inspectorDomain) Detached(ctx context.Context) (cdpevent.InspectorDetachedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.InspectorDetached.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &inspectorDetachedClient{Stream: s}, nil
}

// inspectorDetachedClient implements InspectorDetachedClient.
type inspectorDetachedClient struct{ rpcc.Stream }

func (c *inspectorDetachedClient) Recv() (*cdpevent.InspectorDetachedReply, error) {
	event := new(cdpevent.InspectorDetachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Inspector", Op: "Detached Recv", Err: err}
	}
	return event, nil
}

func (d *inspectorDomain) TargetCrashed(ctx context.Context) (cdpevent.InspectorTargetCrashedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.InspectorTargetCrashed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &inspectorTargetCrashedClient{Stream: s}, nil
}

// inspectorTargetCrashedClient implements InspectorTargetCrashedClient.
type inspectorTargetCrashedClient struct{ rpcc.Stream }

func (c *inspectorTargetCrashedClient) Recv() (*cdpevent.InspectorTargetCrashedReply, error) {
	event := new(cdpevent.InspectorTargetCrashedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Inspector", Op: "TargetCrashed Recv", Err: err}
	}
	return event, nil
}

// The LayerTree domain.
type LayerTree interface {
	// Command Enable
	//
	// Enables compositing tree inspection.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables compositing tree inspection.
	Disable(context.Context) error

	// Command CompositingReasons
	//
	// Provides the reasons why the given layer was composited.
	CompositingReasons(context.Context, *cdpcmd.LayerTreeCompositingReasonsArgs) (*cdpcmd.LayerTreeCompositingReasonsReply, error)

	// Command MakeSnapshot
	//
	// Returns the layer snapshot identifier.
	MakeSnapshot(context.Context, *cdpcmd.LayerTreeMakeSnapshotArgs) (*cdpcmd.LayerTreeMakeSnapshotReply, error)

	// Command LoadSnapshot
	//
	// Returns the snapshot identifier.
	LoadSnapshot(context.Context, *cdpcmd.LayerTreeLoadSnapshotArgs) (*cdpcmd.LayerTreeLoadSnapshotReply, error)

	// Command ReleaseSnapshot
	//
	// Releases layer snapshot captured by the back-end.
	ReleaseSnapshot(context.Context, *cdpcmd.LayerTreeReleaseSnapshotArgs) error

	// Command ProfileSnapshot
	//
	//
	ProfileSnapshot(context.Context, *cdpcmd.LayerTreeProfileSnapshotArgs) (*cdpcmd.LayerTreeProfileSnapshotReply, error)

	// Command ReplaySnapshot
	//
	// Replays the layer snapshot and returns the resulting bitmap.
	ReplaySnapshot(context.Context, *cdpcmd.LayerTreeReplaySnapshotArgs) (*cdpcmd.LayerTreeReplaySnapshotReply, error)

	// Command SnapshotCommandLog
	//
	// Replays the layer snapshot and returns canvas log.
	SnapshotCommandLog(context.Context, *cdpcmd.LayerTreeSnapshotCommandLogArgs) (*cdpcmd.LayerTreeSnapshotCommandLogReply, error)

	// Event LayerTreeDidChange
	//
	//
	LayerTreeDidChange(context.Context) (cdpevent.LayerTreeDidChangeClient, error)

	// Event LayerPainted
	//
	//
	LayerPainted(context.Context) (cdpevent.LayerTreeLayerPaintedClient, error)
}

// layertreeDomain implements the LayerTree domain.
type layertreeDomain struct{ conn *rpcc.Conn }

func (d *layertreeDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "Enable", Err: err}
	}
	return
}

func (d *layertreeDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "Disable", Err: err}
	}
	return
}

func (d *layertreeDomain) CompositingReasons(ctx context.Context, args *cdpcmd.LayerTreeCompositingReasonsArgs) (reply *cdpcmd.LayerTreeCompositingReasonsReply, err error) {
	reply = new(cdpcmd.LayerTreeCompositingReasonsReply)

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeCompositingReasons.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "CompositingReasons", Err: err}
	}
	return
}

// NewLayerTreeCompositingReasonsArgs initializes the arguments for CompositingReasons.
func NewLayerTreeCompositingReasonsArgs(layerID cdptype.LayerTreeLayerID) *cdpcmd.LayerTreeCompositingReasonsArgs {
	args := new(cdpcmd.LayerTreeCompositingReasonsArgs)
	args.LayerID = layerID
	return args
}

func (d *layertreeDomain) MakeSnapshot(ctx context.Context, args *cdpcmd.LayerTreeMakeSnapshotArgs) (reply *cdpcmd.LayerTreeMakeSnapshotReply, err error) {
	reply = new(cdpcmd.LayerTreeMakeSnapshotReply)

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeMakeSnapshot.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "MakeSnapshot", Err: err}
	}
	return
}

// NewLayerTreeMakeSnapshotArgs initializes the arguments for MakeSnapshot.
func NewLayerTreeMakeSnapshotArgs(layerID cdptype.LayerTreeLayerID) *cdpcmd.LayerTreeMakeSnapshotArgs {
	args := new(cdpcmd.LayerTreeMakeSnapshotArgs)
	args.LayerID = layerID
	return args
}

func (d *layertreeDomain) LoadSnapshot(ctx context.Context, args *cdpcmd.LayerTreeLoadSnapshotArgs) (reply *cdpcmd.LayerTreeLoadSnapshotReply, err error) {
	reply = new(cdpcmd.LayerTreeLoadSnapshotReply)

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeLoadSnapshot.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "LoadSnapshot", Err: err}
	}
	return
}

// NewLayerTreeLoadSnapshotArgs initializes the arguments for LoadSnapshot.
func NewLayerTreeLoadSnapshotArgs(tiles []cdptype.LayerTreePictureTile) *cdpcmd.LayerTreeLoadSnapshotArgs {
	args := new(cdpcmd.LayerTreeLoadSnapshotArgs)
	args.Tiles = tiles
	return args
}

func (d *layertreeDomain) ReleaseSnapshot(ctx context.Context, args *cdpcmd.LayerTreeReleaseSnapshotArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeReleaseSnapshot.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "ReleaseSnapshot", Err: err}
	}
	return
}

// NewLayerTreeReleaseSnapshotArgs initializes the arguments for ReleaseSnapshot.
func NewLayerTreeReleaseSnapshotArgs(snapshotID cdptype.LayerTreeSnapshotID) *cdpcmd.LayerTreeReleaseSnapshotArgs {
	args := new(cdpcmd.LayerTreeReleaseSnapshotArgs)
	args.SnapshotID = snapshotID
	return args
}

func (d *layertreeDomain) ProfileSnapshot(ctx context.Context, args *cdpcmd.LayerTreeProfileSnapshotArgs) (reply *cdpcmd.LayerTreeProfileSnapshotReply, err error) {
	reply = new(cdpcmd.LayerTreeProfileSnapshotReply)

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeProfileSnapshot.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "ProfileSnapshot", Err: err}
	}
	return
}

// NewLayerTreeProfileSnapshotArgs initializes the arguments for ProfileSnapshot.
func NewLayerTreeProfileSnapshotArgs(snapshotID cdptype.LayerTreeSnapshotID) *cdpcmd.LayerTreeProfileSnapshotArgs {
	args := new(cdpcmd.LayerTreeProfileSnapshotArgs)
	args.SnapshotID = snapshotID
	return args
}

func (d *layertreeDomain) ReplaySnapshot(ctx context.Context, args *cdpcmd.LayerTreeReplaySnapshotArgs) (reply *cdpcmd.LayerTreeReplaySnapshotReply, err error) {
	reply = new(cdpcmd.LayerTreeReplaySnapshotReply)

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeReplaySnapshot.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "ReplaySnapshot", Err: err}
	}
	return
}

// NewLayerTreeReplaySnapshotArgs initializes the arguments for ReplaySnapshot.
func NewLayerTreeReplaySnapshotArgs(snapshotID cdptype.LayerTreeSnapshotID) *cdpcmd.LayerTreeReplaySnapshotArgs {
	args := new(cdpcmd.LayerTreeReplaySnapshotArgs)
	args.SnapshotID = snapshotID
	return args
}

func (d *layertreeDomain) SnapshotCommandLog(ctx context.Context, args *cdpcmd.LayerTreeSnapshotCommandLogArgs) (reply *cdpcmd.LayerTreeSnapshotCommandLogReply, err error) {
	reply = new(cdpcmd.LayerTreeSnapshotCommandLogReply)

	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeSnapshotCommandLog.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "LayerTree", Op: "SnapshotCommandLog", Err: err}
	}
	return
}

// NewLayerTreeSnapshotCommandLogArgs initializes the arguments for SnapshotCommandLog.
func NewLayerTreeSnapshotCommandLogArgs(snapshotID cdptype.LayerTreeSnapshotID) *cdpcmd.LayerTreeSnapshotCommandLogArgs {
	args := new(cdpcmd.LayerTreeSnapshotCommandLogArgs)
	args.SnapshotID = snapshotID
	return args
}

func (d *layertreeDomain) LayerTreeDidChange(ctx context.Context) (cdpevent.LayerTreeDidChangeClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.LayerTreeDidChange.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &layertreeLayerTreeDidChangeClient{Stream: s}, nil
}

// layertreeLayerTreeDidChangeClient implements LayerTreeDidChangeClient.
type layertreeLayerTreeDidChangeClient struct{ rpcc.Stream }

func (c *layertreeLayerTreeDidChangeClient) Recv() (*cdpevent.LayerTreeDidChangeReply, error) {
	event := new(cdpevent.LayerTreeDidChangeReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "LayerTree", Op: "LayerTreeDidChange Recv", Err: err}
	}
	return event, nil
}

func (d *layertreeDomain) LayerPainted(ctx context.Context) (cdpevent.LayerTreeLayerPaintedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.LayerTreeLayerPainted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &layertreeLayerPaintedClient{Stream: s}, nil
}

// layertreeLayerPaintedClient implements LayerTreeLayerPaintedClient.
type layertreeLayerPaintedClient struct{ rpcc.Stream }

func (c *layertreeLayerPaintedClient) Recv() (*cdpevent.LayerTreeLayerPaintedReply, error) {
	event := new(cdpevent.LayerTreeLayerPaintedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "LayerTree", Op: "LayerPainted Recv", Err: err}
	}
	return event, nil
}

// The Log domain. Provides access to log entries.
type Log interface {
	// Command Enable
	//
	// Enables log domain, sends the entries collected so far to the client by means of the entryAdded notification.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables log domain, prevents further log entries from being reported to the client.
	Disable(context.Context) error

	// Command Clear
	//
	// Clears the log.
	Clear(context.Context) error

	// Command StartViolationsReport
	//
	// start violation reporting.
	StartViolationsReport(context.Context, *cdpcmd.LogStartViolationsReportArgs) error

	// Command StopViolationsReport
	//
	// Stop violation reporting.
	StopViolationsReport(context.Context) error

	// Event EntryAdded
	//
	// Issued when new message was logged.
	EntryAdded(context.Context) (cdpevent.LogEntryAddedClient, error)
}

// logDomain implements the Log domain.
type logDomain struct{ conn *rpcc.Conn }

func (d *logDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.LogEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Log", Op: "Enable", Err: err}
	}
	return
}

func (d *logDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.LogDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Log", Op: "Disable", Err: err}
	}
	return
}

func (d *logDomain) Clear(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.LogClear.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Log", Op: "Clear", Err: err}
	}
	return
}

func (d *logDomain) StartViolationsReport(ctx context.Context, args *cdpcmd.LogStartViolationsReportArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.LogStartViolationsReport.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Log", Op: "StartViolationsReport", Err: err}
	}
	return
}

// NewLogStartViolationsReportArgs initializes the arguments for StartViolationsReport.
func NewLogStartViolationsReportArgs(config []cdptype.LogViolationSetting) *cdpcmd.LogStartViolationsReportArgs {
	args := new(cdpcmd.LogStartViolationsReportArgs)
	args.Config = config
	return args
}

func (d *logDomain) StopViolationsReport(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.LogStopViolationsReport.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Log", Op: "StopViolationsReport", Err: err}
	}
	return
}

func (d *logDomain) EntryAdded(ctx context.Context) (cdpevent.LogEntryAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.LogEntryAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &logEntryAddedClient{Stream: s}, nil
}

// logEntryAddedClient implements LogEntryAddedClient.
type logEntryAddedClient struct{ rpcc.Stream }

func (c *logEntryAddedClient) Recv() (*cdpevent.LogEntryAddedReply, error) {
	event := new(cdpevent.LogEntryAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Log", Op: "EntryAdded Recv", Err: err}
	}
	return event, nil
}

// The Memory domain.
type Memory interface {
	// Command GetDOMCounters
	//
	//
	GetDOMCounters(context.Context) (*cdpcmd.MemoryGetDOMCountersReply, error)

	// Command SetPressureNotificationsSuppressed
	//
	// Enable/disable suppressing memory pressure notifications in all processes.
	SetPressureNotificationsSuppressed(context.Context, *cdpcmd.MemorySetPressureNotificationsSuppressedArgs) error

	// Command SimulatePressureNotification
	//
	// Simulate a memory pressure notification in all processes.
	SimulatePressureNotification(context.Context, *cdpcmd.MemorySimulatePressureNotificationArgs) error
}

// memoryDomain implements the Memory domain.
type memoryDomain struct{ conn *rpcc.Conn }

func (d *memoryDomain) GetDOMCounters(ctx context.Context) (reply *cdpcmd.MemoryGetDOMCountersReply, err error) {
	reply = new(cdpcmd.MemoryGetDOMCountersReply)

	err = rpcc.Invoke(ctx, cdpcmd.MemoryGetDOMCounters.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Memory", Op: "GetDOMCounters", Err: err}
	}
	return
}

func (d *memoryDomain) SetPressureNotificationsSuppressed(ctx context.Context, args *cdpcmd.MemorySetPressureNotificationsSuppressedArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.MemorySetPressureNotificationsSuppressed.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Memory", Op: "SetPressureNotificationsSuppressed", Err: err}
	}
	return
}

// NewMemorySetPressureNotificationsSuppressedArgs initializes the arguments for SetPressureNotificationsSuppressed.
func NewMemorySetPressureNotificationsSuppressedArgs(suppressed bool) *cdpcmd.MemorySetPressureNotificationsSuppressedArgs {
	args := new(cdpcmd.MemorySetPressureNotificationsSuppressedArgs)
	args.Suppressed = suppressed
	return args
}

func (d *memoryDomain) SimulatePressureNotification(ctx context.Context, args *cdpcmd.MemorySimulatePressureNotificationArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.MemorySimulatePressureNotification.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Memory", Op: "SimulatePressureNotification", Err: err}
	}
	return
}

// NewMemorySimulatePressureNotificationArgs initializes the arguments for SimulatePressureNotification.
func NewMemorySimulatePressureNotificationArgs(level cdptype.MemoryPressureLevel) *cdpcmd.MemorySimulatePressureNotificationArgs {
	args := new(cdpcmd.MemorySimulatePressureNotificationArgs)
	args.Level = level
	return args
}

// The Network domain. Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc.
type Network interface {
	// Command Enable
	//
	// Enables network tracking, network events will now be delivered to the client.
	Enable(context.Context, *cdpcmd.NetworkEnableArgs) error

	// Command Disable
	//
	// Disables network tracking, prevents network events from being sent to the client.
	Disable(context.Context) error

	// Command SetUserAgentOverride
	//
	// Allows overriding user agent with the given string.
	SetUserAgentOverride(context.Context, *cdpcmd.NetworkSetUserAgentOverrideArgs) error

	// Command SetExtraHTTPHeaders
	//
	// Specifies whether to always send extra HTTP headers with the requests from this page.
	SetExtraHTTPHeaders(context.Context, *cdpcmd.NetworkSetExtraHTTPHeadersArgs) error

	// Command GetResponseBody
	//
	// Returns content served for the given request.
	GetResponseBody(context.Context, *cdpcmd.NetworkGetResponseBodyArgs) (*cdpcmd.NetworkGetResponseBodyReply, error)

	// Command SetBlockedURLs
	//
	// Blocks specific URL from loading.
	SetBlockedURLs(context.Context, *cdpcmd.NetworkSetBlockedURLsArgs) error

	// Command ReplayXHR
	//
	// This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.
	ReplayXHR(context.Context, *cdpcmd.NetworkReplayXHRArgs) error

	// Command SetMonitoringXHREnabled
	//
	// Toggles monitoring of XMLHttpRequest. If true, console will receive messages upon each XHR issued.
	SetMonitoringXHREnabled(context.Context, *cdpcmd.NetworkSetMonitoringXHREnabledArgs) error

	// Command CanClearBrowserCache
	//
	// Tells whether clearing browser cache is supported.
	CanClearBrowserCache(context.Context) (*cdpcmd.NetworkCanClearBrowserCacheReply, error)

	// Command ClearBrowserCache
	//
	// Clears browser cache.
	ClearBrowserCache(context.Context) error

	// Command CanClearBrowserCookies
	//
	// Tells whether clearing browser cookies is supported.
	CanClearBrowserCookies(context.Context) (*cdpcmd.NetworkCanClearBrowserCookiesReply, error)

	// Command ClearBrowserCookies
	//
	// Clears browser cookies.
	ClearBrowserCookies(context.Context) error

	// Command GetCookies
	//
	// Returns all browser cookies for the current URL. Depending on the backend support, will return detailed cookie information in the cookies field.
	GetCookies(context.Context, *cdpcmd.NetworkGetCookiesArgs) (*cdpcmd.NetworkGetCookiesReply, error)

	// Command GetAllCookies
	//
	// Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the cookies field.
	GetAllCookies(context.Context) (*cdpcmd.NetworkGetAllCookiesReply, error)

	// Command DeleteCookie
	//
	// Deletes browser cookie with given name, domain and path.
	DeleteCookie(context.Context, *cdpcmd.NetworkDeleteCookieArgs) error

	// Command SetCookie
	//
	// Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
	SetCookie(context.Context, *cdpcmd.NetworkSetCookieArgs) (*cdpcmd.NetworkSetCookieReply, error)

	// Command CanEmulateNetworkConditions
	//
	// Tells whether emulation of network conditions is supported.
	CanEmulateNetworkConditions(context.Context) (*cdpcmd.NetworkCanEmulateNetworkConditionsReply, error)

	// Command EmulateNetworkConditions
	//
	// Activates emulation of network conditions.
	EmulateNetworkConditions(context.Context, *cdpcmd.NetworkEmulateNetworkConditionsArgs) error

	// Command SetCacheDisabled
	//
	// Toggles ignoring cache for each request. If true, cache will not be used.
	SetCacheDisabled(context.Context, *cdpcmd.NetworkSetCacheDisabledArgs) error

	// Command SetBypassServiceWorker
	//
	// Toggles ignoring of service worker for each request.
	SetBypassServiceWorker(context.Context, *cdpcmd.NetworkSetBypassServiceWorkerArgs) error

	// Command SetDataSizeLimitsForTest
	//
	// For testing.
	SetDataSizeLimitsForTest(context.Context, *cdpcmd.NetworkSetDataSizeLimitsForTestArgs) error

	// Command GetCertificate
	//
	// Returns the DER-encoded certificate.
	GetCertificate(context.Context, *cdpcmd.NetworkGetCertificateArgs) (*cdpcmd.NetworkGetCertificateReply, error)

	// Event ResourceChangedPriority
	//
	// Fired when resource loading priority is changed
	ResourceChangedPriority(context.Context) (cdpevent.NetworkResourceChangedPriorityClient, error)

	// Event RequestWillBeSent
	//
	// Fired when page is about to send HTTP request.
	RequestWillBeSent(context.Context) (cdpevent.NetworkRequestWillBeSentClient, error)

	// Event RequestServedFromCache
	//
	// Fired if request ended up loading from cache.
	RequestServedFromCache(context.Context) (cdpevent.NetworkRequestServedFromCacheClient, error)

	// Event ResponseReceived
	//
	// Fired when HTTP response is available.
	ResponseReceived(context.Context) (cdpevent.NetworkResponseReceivedClient, error)

	// Event DataReceived
	//
	// Fired when data chunk was received over the network.
	DataReceived(context.Context) (cdpevent.NetworkDataReceivedClient, error)

	// Event LoadingFinished
	//
	// Fired when HTTP request has finished loading.
	LoadingFinished(context.Context) (cdpevent.NetworkLoadingFinishedClient, error)

	// Event LoadingFailed
	//
	// Fired when HTTP request has failed to load.
	LoadingFailed(context.Context) (cdpevent.NetworkLoadingFailedClient, error)

	// Event WebSocketWillSendHandshakeRequest
	//
	// Fired when WebSocket is about to initiate handshake.
	WebSocketWillSendHandshakeRequest(context.Context) (cdpevent.NetworkWebSocketWillSendHandshakeRequestClient, error)

	// Event WebSocketHandshakeResponseReceived
	//
	// Fired when WebSocket handshake response becomes available.
	WebSocketHandshakeResponseReceived(context.Context) (cdpevent.NetworkWebSocketHandshakeResponseReceivedClient, error)

	// Event WebSocketCreated
	//
	// Fired upon WebSocket creation.
	WebSocketCreated(context.Context) (cdpevent.NetworkWebSocketCreatedClient, error)

	// Event WebSocketClosed
	//
	// Fired when WebSocket is closed.
	WebSocketClosed(context.Context) (cdpevent.NetworkWebSocketClosedClient, error)

	// Event WebSocketFrameReceived
	//
	// Fired when WebSocket frame is received.
	WebSocketFrameReceived(context.Context) (cdpevent.NetworkWebSocketFrameReceivedClient, error)

	// Event WebSocketFrameError
	//
	// Fired when WebSocket frame error occurs.
	WebSocketFrameError(context.Context) (cdpevent.NetworkWebSocketFrameErrorClient, error)

	// Event WebSocketFrameSent
	//
	// Fired when WebSocket frame is sent.
	WebSocketFrameSent(context.Context) (cdpevent.NetworkWebSocketFrameSentClient, error)

	// Event EventSourceMessageReceived
	//
	// Fired when EventSource message is received.
	EventSourceMessageReceived(context.Context) (cdpevent.NetworkEventSourceMessageReceivedClient, error)
}

// networkDomain implements the Network domain.
type networkDomain struct{ conn *rpcc.Conn }

func (d *networkDomain) Enable(ctx context.Context, args *cdpcmd.NetworkEnableArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkEnable.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "Enable", Err: err}
	}
	return
}

// NewNetworkEnableArgs initializes the arguments for Enable.
func NewNetworkEnableArgs() *cdpcmd.NetworkEnableArgs {
	args := new(cdpcmd.NetworkEnableArgs)

	return args
}

func (d *networkDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "Disable", Err: err}
	}
	return
}

func (d *networkDomain) SetUserAgentOverride(ctx context.Context, args *cdpcmd.NetworkSetUserAgentOverrideArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkSetUserAgentOverride.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "SetUserAgentOverride", Err: err}
	}
	return
}

// NewNetworkSetUserAgentOverrideArgs initializes the arguments for SetUserAgentOverride.
func NewNetworkSetUserAgentOverrideArgs(userAgent string) *cdpcmd.NetworkSetUserAgentOverrideArgs {
	args := new(cdpcmd.NetworkSetUserAgentOverrideArgs)
	args.UserAgent = userAgent
	return args
}

func (d *networkDomain) SetExtraHTTPHeaders(ctx context.Context, args *cdpcmd.NetworkSetExtraHTTPHeadersArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkSetExtraHTTPHeaders.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "SetExtraHTTPHeaders", Err: err}
	}
	return
}

// NewNetworkSetExtraHTTPHeadersArgs initializes the arguments for SetExtraHTTPHeaders.
func NewNetworkSetExtraHTTPHeadersArgs(headers cdptype.NetworkHeaders) *cdpcmd.NetworkSetExtraHTTPHeadersArgs {
	args := new(cdpcmd.NetworkSetExtraHTTPHeadersArgs)
	args.Headers = headers
	return args
}

func (d *networkDomain) GetResponseBody(ctx context.Context, args *cdpcmd.NetworkGetResponseBodyArgs) (reply *cdpcmd.NetworkGetResponseBodyReply, err error) {
	reply = new(cdpcmd.NetworkGetResponseBodyReply)

	err = rpcc.Invoke(ctx, cdpcmd.NetworkGetResponseBody.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "GetResponseBody", Err: err}
	}
	return
}

// NewNetworkGetResponseBodyArgs initializes the arguments for GetResponseBody.
func NewNetworkGetResponseBodyArgs(requestID cdptype.NetworkRequestID) *cdpcmd.NetworkGetResponseBodyArgs {
	args := new(cdpcmd.NetworkGetResponseBodyArgs)
	args.RequestID = requestID
	return args
}

func (d *networkDomain) SetBlockedURLs(ctx context.Context, args *cdpcmd.NetworkSetBlockedURLsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkSetBlockedURLs.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "SetBlockedURLs", Err: err}
	}
	return
}

// NewNetworkSetBlockedURLsArgs initializes the arguments for SetBlockedURLs.
func NewNetworkSetBlockedURLsArgs(urls []string) *cdpcmd.NetworkSetBlockedURLsArgs {
	args := new(cdpcmd.NetworkSetBlockedURLsArgs)
	args.Urls = urls
	return args
}

func (d *networkDomain) ReplayXHR(ctx context.Context, args *cdpcmd.NetworkReplayXHRArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkReplayXHR.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "ReplayXHR", Err: err}
	}
	return
}

// NewNetworkReplayXHRArgs initializes the arguments for ReplayXHR.
func NewNetworkReplayXHRArgs(requestID cdptype.NetworkRequestID) *cdpcmd.NetworkReplayXHRArgs {
	args := new(cdpcmd.NetworkReplayXHRArgs)
	args.RequestID = requestID
	return args
}

func (d *networkDomain) SetMonitoringXHREnabled(ctx context.Context, args *cdpcmd.NetworkSetMonitoringXHREnabledArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkSetMonitoringXHREnabled.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "SetMonitoringXHREnabled", Err: err}
	}
	return
}

// NewNetworkSetMonitoringXHREnabledArgs initializes the arguments for SetMonitoringXHREnabled.
func NewNetworkSetMonitoringXHREnabledArgs(enabled bool) *cdpcmd.NetworkSetMonitoringXHREnabledArgs {
	args := new(cdpcmd.NetworkSetMonitoringXHREnabledArgs)
	args.Enabled = enabled
	return args
}

func (d *networkDomain) CanClearBrowserCache(ctx context.Context) (reply *cdpcmd.NetworkCanClearBrowserCacheReply, err error) {
	reply = new(cdpcmd.NetworkCanClearBrowserCacheReply)

	err = rpcc.Invoke(ctx, cdpcmd.NetworkCanClearBrowserCache.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "CanClearBrowserCache", Err: err}
	}
	return
}

func (d *networkDomain) ClearBrowserCache(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkClearBrowserCache.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "ClearBrowserCache", Err: err}
	}
	return
}

func (d *networkDomain) CanClearBrowserCookies(ctx context.Context) (reply *cdpcmd.NetworkCanClearBrowserCookiesReply, err error) {
	reply = new(cdpcmd.NetworkCanClearBrowserCookiesReply)

	err = rpcc.Invoke(ctx, cdpcmd.NetworkCanClearBrowserCookies.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "CanClearBrowserCookies", Err: err}
	}
	return
}

func (d *networkDomain) ClearBrowserCookies(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkClearBrowserCookies.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "ClearBrowserCookies", Err: err}
	}
	return
}

func (d *networkDomain) GetCookies(ctx context.Context, args *cdpcmd.NetworkGetCookiesArgs) (reply *cdpcmd.NetworkGetCookiesReply, err error) {
	reply = new(cdpcmd.NetworkGetCookiesReply)

	err = rpcc.Invoke(ctx, cdpcmd.NetworkGetCookies.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "GetCookies", Err: err}
	}
	return
}

// NewNetworkGetCookiesArgs initializes the arguments for GetCookies.
func NewNetworkGetCookiesArgs() *cdpcmd.NetworkGetCookiesArgs {
	args := new(cdpcmd.NetworkGetCookiesArgs)

	return args
}

func (d *networkDomain) GetAllCookies(ctx context.Context) (reply *cdpcmd.NetworkGetAllCookiesReply, err error) {
	reply = new(cdpcmd.NetworkGetAllCookiesReply)

	err = rpcc.Invoke(ctx, cdpcmd.NetworkGetAllCookies.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "GetAllCookies", Err: err}
	}
	return
}

func (d *networkDomain) DeleteCookie(ctx context.Context, args *cdpcmd.NetworkDeleteCookieArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkDeleteCookie.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "DeleteCookie", Err: err}
	}
	return
}

// NewNetworkDeleteCookieArgs initializes the arguments for DeleteCookie.
func NewNetworkDeleteCookieArgs(cookieName string, url string) *cdpcmd.NetworkDeleteCookieArgs {
	args := new(cdpcmd.NetworkDeleteCookieArgs)
	args.CookieName = cookieName
	args.URL = url
	return args
}

func (d *networkDomain) SetCookie(ctx context.Context, args *cdpcmd.NetworkSetCookieArgs) (reply *cdpcmd.NetworkSetCookieReply, err error) {
	reply = new(cdpcmd.NetworkSetCookieReply)

	err = rpcc.Invoke(ctx, cdpcmd.NetworkSetCookie.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "SetCookie", Err: err}
	}
	return
}

// NewNetworkSetCookieArgs initializes the arguments for SetCookie.
func NewNetworkSetCookieArgs(url string, name string, value string) *cdpcmd.NetworkSetCookieArgs {
	args := new(cdpcmd.NetworkSetCookieArgs)
	args.URL = url
	args.Name = name
	args.Value = value
	return args
}

func (d *networkDomain) CanEmulateNetworkConditions(ctx context.Context) (reply *cdpcmd.NetworkCanEmulateNetworkConditionsReply, err error) {
	reply = new(cdpcmd.NetworkCanEmulateNetworkConditionsReply)

	err = rpcc.Invoke(ctx, cdpcmd.NetworkCanEmulateNetworkConditions.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "CanEmulateNetworkConditions", Err: err}
	}
	return
}

func (d *networkDomain) EmulateNetworkConditions(ctx context.Context, args *cdpcmd.NetworkEmulateNetworkConditionsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkEmulateNetworkConditions.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "EmulateNetworkConditions", Err: err}
	}
	return
}

// NewNetworkEmulateNetworkConditionsArgs initializes the arguments for EmulateNetworkConditions.
func NewNetworkEmulateNetworkConditionsArgs(offline bool, latency float64, downloadThroughput float64, uploadThroughput float64) *cdpcmd.NetworkEmulateNetworkConditionsArgs {
	args := new(cdpcmd.NetworkEmulateNetworkConditionsArgs)
	args.Offline = offline
	args.Latency = latency
	args.DownloadThroughput = downloadThroughput
	args.UploadThroughput = uploadThroughput
	return args
}

func (d *networkDomain) SetCacheDisabled(ctx context.Context, args *cdpcmd.NetworkSetCacheDisabledArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkSetCacheDisabled.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "SetCacheDisabled", Err: err}
	}
	return
}

// NewNetworkSetCacheDisabledArgs initializes the arguments for SetCacheDisabled.
func NewNetworkSetCacheDisabledArgs(cacheDisabled bool) *cdpcmd.NetworkSetCacheDisabledArgs {
	args := new(cdpcmd.NetworkSetCacheDisabledArgs)
	args.CacheDisabled = cacheDisabled
	return args
}

func (d *networkDomain) SetBypassServiceWorker(ctx context.Context, args *cdpcmd.NetworkSetBypassServiceWorkerArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkSetBypassServiceWorker.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "SetBypassServiceWorker", Err: err}
	}
	return
}

// NewNetworkSetBypassServiceWorkerArgs initializes the arguments for SetBypassServiceWorker.
func NewNetworkSetBypassServiceWorkerArgs(bypass bool) *cdpcmd.NetworkSetBypassServiceWorkerArgs {
	args := new(cdpcmd.NetworkSetBypassServiceWorkerArgs)
	args.Bypass = bypass
	return args
}

func (d *networkDomain) SetDataSizeLimitsForTest(ctx context.Context, args *cdpcmd.NetworkSetDataSizeLimitsForTestArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.NetworkSetDataSizeLimitsForTest.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "SetDataSizeLimitsForTest", Err: err}
	}
	return
}

// NewNetworkSetDataSizeLimitsForTestArgs initializes the arguments for SetDataSizeLimitsForTest.
func NewNetworkSetDataSizeLimitsForTestArgs(maxTotalSize int, maxResourceSize int) *cdpcmd.NetworkSetDataSizeLimitsForTestArgs {
	args := new(cdpcmd.NetworkSetDataSizeLimitsForTestArgs)
	args.MaxTotalSize = maxTotalSize
	args.MaxResourceSize = maxResourceSize
	return args
}

func (d *networkDomain) GetCertificate(ctx context.Context, args *cdpcmd.NetworkGetCertificateArgs) (reply *cdpcmd.NetworkGetCertificateReply, err error) {
	reply = new(cdpcmd.NetworkGetCertificateReply)

	err = rpcc.Invoke(ctx, cdpcmd.NetworkGetCertificate.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Network", Op: "GetCertificate", Err: err}
	}
	return
}

// NewNetworkGetCertificateArgs initializes the arguments for GetCertificate.
func NewNetworkGetCertificateArgs(origin string) *cdpcmd.NetworkGetCertificateArgs {
	args := new(cdpcmd.NetworkGetCertificateArgs)
	args.Origin = origin
	return args
}

func (d *networkDomain) ResourceChangedPriority(ctx context.Context) (cdpevent.NetworkResourceChangedPriorityClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkResourceChangedPriority.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkResourceChangedPriorityClient{Stream: s}, nil
}

// networkResourceChangedPriorityClient implements NetworkResourceChangedPriorityClient.
type networkResourceChangedPriorityClient struct{ rpcc.Stream }

func (c *networkResourceChangedPriorityClient) Recv() (*cdpevent.NetworkResourceChangedPriorityReply, error) {
	event := new(cdpevent.NetworkResourceChangedPriorityReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "ResourceChangedPriority Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) RequestWillBeSent(ctx context.Context) (cdpevent.NetworkRequestWillBeSentClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkRequestWillBeSent.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkRequestWillBeSentClient{Stream: s}, nil
}

// networkRequestWillBeSentClient implements NetworkRequestWillBeSentClient.
type networkRequestWillBeSentClient struct{ rpcc.Stream }

func (c *networkRequestWillBeSentClient) Recv() (*cdpevent.NetworkRequestWillBeSentReply, error) {
	event := new(cdpevent.NetworkRequestWillBeSentReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "RequestWillBeSent Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) RequestServedFromCache(ctx context.Context) (cdpevent.NetworkRequestServedFromCacheClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkRequestServedFromCache.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkRequestServedFromCacheClient{Stream: s}, nil
}

// networkRequestServedFromCacheClient implements NetworkRequestServedFromCacheClient.
type networkRequestServedFromCacheClient struct{ rpcc.Stream }

func (c *networkRequestServedFromCacheClient) Recv() (*cdpevent.NetworkRequestServedFromCacheReply, error) {
	event := new(cdpevent.NetworkRequestServedFromCacheReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "RequestServedFromCache Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) ResponseReceived(ctx context.Context) (cdpevent.NetworkResponseReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkResponseReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkResponseReceivedClient{Stream: s}, nil
}

// networkResponseReceivedClient implements NetworkResponseReceivedClient.
type networkResponseReceivedClient struct{ rpcc.Stream }

func (c *networkResponseReceivedClient) Recv() (*cdpevent.NetworkResponseReceivedReply, error) {
	event := new(cdpevent.NetworkResponseReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "ResponseReceived Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) DataReceived(ctx context.Context) (cdpevent.NetworkDataReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkDataReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkDataReceivedClient{Stream: s}, nil
}

// networkDataReceivedClient implements NetworkDataReceivedClient.
type networkDataReceivedClient struct{ rpcc.Stream }

func (c *networkDataReceivedClient) Recv() (*cdpevent.NetworkDataReceivedReply, error) {
	event := new(cdpevent.NetworkDataReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "DataReceived Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) LoadingFinished(ctx context.Context) (cdpevent.NetworkLoadingFinishedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkLoadingFinished.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkLoadingFinishedClient{Stream: s}, nil
}

// networkLoadingFinishedClient implements NetworkLoadingFinishedClient.
type networkLoadingFinishedClient struct{ rpcc.Stream }

func (c *networkLoadingFinishedClient) Recv() (*cdpevent.NetworkLoadingFinishedReply, error) {
	event := new(cdpevent.NetworkLoadingFinishedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "LoadingFinished Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) LoadingFailed(ctx context.Context) (cdpevent.NetworkLoadingFailedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkLoadingFailed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkLoadingFailedClient{Stream: s}, nil
}

// networkLoadingFailedClient implements NetworkLoadingFailedClient.
type networkLoadingFailedClient struct{ rpcc.Stream }

func (c *networkLoadingFailedClient) Recv() (*cdpevent.NetworkLoadingFailedReply, error) {
	event := new(cdpevent.NetworkLoadingFailedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "LoadingFailed Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) WebSocketWillSendHandshakeRequest(ctx context.Context) (cdpevent.NetworkWebSocketWillSendHandshakeRequestClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketWillSendHandshakeRequest.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkWebSocketWillSendHandshakeRequestClient{Stream: s}, nil
}

// networkWebSocketWillSendHandshakeRequestClient implements NetworkWebSocketWillSendHandshakeRequestClient.
type networkWebSocketWillSendHandshakeRequestClient struct{ rpcc.Stream }

func (c *networkWebSocketWillSendHandshakeRequestClient) Recv() (*cdpevent.NetworkWebSocketWillSendHandshakeRequestReply, error) {
	event := new(cdpevent.NetworkWebSocketWillSendHandshakeRequestReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "WebSocketWillSendHandshakeRequest Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) WebSocketHandshakeResponseReceived(ctx context.Context) (cdpevent.NetworkWebSocketHandshakeResponseReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketHandshakeResponseReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkWebSocketHandshakeResponseReceivedClient{Stream: s}, nil
}

// networkWebSocketHandshakeResponseReceivedClient implements NetworkWebSocketHandshakeResponseReceivedClient.
type networkWebSocketHandshakeResponseReceivedClient struct{ rpcc.Stream }

func (c *networkWebSocketHandshakeResponseReceivedClient) Recv() (*cdpevent.NetworkWebSocketHandshakeResponseReceivedReply, error) {
	event := new(cdpevent.NetworkWebSocketHandshakeResponseReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "WebSocketHandshakeResponseReceived Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) WebSocketCreated(ctx context.Context) (cdpevent.NetworkWebSocketCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketCreated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkWebSocketCreatedClient{Stream: s}, nil
}

// networkWebSocketCreatedClient implements NetworkWebSocketCreatedClient.
type networkWebSocketCreatedClient struct{ rpcc.Stream }

func (c *networkWebSocketCreatedClient) Recv() (*cdpevent.NetworkWebSocketCreatedReply, error) {
	event := new(cdpevent.NetworkWebSocketCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "WebSocketCreated Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) WebSocketClosed(ctx context.Context) (cdpevent.NetworkWebSocketClosedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketClosed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkWebSocketClosedClient{Stream: s}, nil
}

// networkWebSocketClosedClient implements NetworkWebSocketClosedClient.
type networkWebSocketClosedClient struct{ rpcc.Stream }

func (c *networkWebSocketClosedClient) Recv() (*cdpevent.NetworkWebSocketClosedReply, error) {
	event := new(cdpevent.NetworkWebSocketClosedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "WebSocketClosed Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) WebSocketFrameReceived(ctx context.Context) (cdpevent.NetworkWebSocketFrameReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketFrameReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkWebSocketFrameReceivedClient{Stream: s}, nil
}

// networkWebSocketFrameReceivedClient implements NetworkWebSocketFrameReceivedClient.
type networkWebSocketFrameReceivedClient struct{ rpcc.Stream }

func (c *networkWebSocketFrameReceivedClient) Recv() (*cdpevent.NetworkWebSocketFrameReceivedReply, error) {
	event := new(cdpevent.NetworkWebSocketFrameReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "WebSocketFrameReceived Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) WebSocketFrameError(ctx context.Context) (cdpevent.NetworkWebSocketFrameErrorClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketFrameError.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkWebSocketFrameErrorClient{Stream: s}, nil
}

// networkWebSocketFrameErrorClient implements NetworkWebSocketFrameErrorClient.
type networkWebSocketFrameErrorClient struct{ rpcc.Stream }

func (c *networkWebSocketFrameErrorClient) Recv() (*cdpevent.NetworkWebSocketFrameErrorReply, error) {
	event := new(cdpevent.NetworkWebSocketFrameErrorReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "WebSocketFrameError Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) WebSocketFrameSent(ctx context.Context) (cdpevent.NetworkWebSocketFrameSentClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketFrameSent.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkWebSocketFrameSentClient{Stream: s}, nil
}

// networkWebSocketFrameSentClient implements NetworkWebSocketFrameSentClient.
type networkWebSocketFrameSentClient struct{ rpcc.Stream }

func (c *networkWebSocketFrameSentClient) Recv() (*cdpevent.NetworkWebSocketFrameSentReply, error) {
	event := new(cdpevent.NetworkWebSocketFrameSentReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "WebSocketFrameSent Recv", Err: err}
	}
	return event, nil
}

func (d *networkDomain) EventSourceMessageReceived(ctx context.Context) (cdpevent.NetworkEventSourceMessageReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkEventSourceMessageReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &networkEventSourceMessageReceivedClient{Stream: s}, nil
}

// networkEventSourceMessageReceivedClient implements NetworkEventSourceMessageReceivedClient.
type networkEventSourceMessageReceivedClient struct{ rpcc.Stream }

func (c *networkEventSourceMessageReceivedClient) Recv() (*cdpevent.NetworkEventSourceMessageReceivedReply, error) {
	event := new(cdpevent.NetworkEventSourceMessageReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Network", Op: "EventSourceMessageReceived Recv", Err: err}
	}
	return event, nil
}

// The Page domain. Actions and events related to the inspected page belong to the page domain.
type Page interface {
	// Command Enable
	//
	// Enables page domain notifications.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables page domain notifications.
	Disable(context.Context) error

	// Command AddScriptToEvaluateOnLoad
	//
	//
	AddScriptToEvaluateOnLoad(context.Context, *cdpcmd.PageAddScriptToEvaluateOnLoadArgs) (*cdpcmd.PageAddScriptToEvaluateOnLoadReply, error)

	// Command RemoveScriptToEvaluateOnLoad
	//
	//
	RemoveScriptToEvaluateOnLoad(context.Context, *cdpcmd.PageRemoveScriptToEvaluateOnLoadArgs) error

	// Command SetAutoAttachToCreatedPages
	//
	// Controls whether browser will open a new inspector window for connected pages.
	SetAutoAttachToCreatedPages(context.Context, *cdpcmd.PageSetAutoAttachToCreatedPagesArgs) error

	// Command Reload
	//
	// Reloads given page optionally ignoring the cache.
	Reload(context.Context, *cdpcmd.PageReloadArgs) error

	// Command Navigate
	//
	// Navigates current page to the given URL.
	Navigate(context.Context, *cdpcmd.PageNavigateArgs) (*cdpcmd.PageNavigateReply, error)

	// Command StopLoading
	//
	// Force the page stop all navigations and pending resource fetches.
	StopLoading(context.Context) error

	// Command GetNavigationHistory
	//
	// Returns navigation history for the current page.
	GetNavigationHistory(context.Context) (*cdpcmd.PageGetNavigationHistoryReply, error)

	// Command NavigateToHistoryEntry
	//
	// Navigates current page to the given history entry.
	NavigateToHistoryEntry(context.Context, *cdpcmd.PageNavigateToHistoryEntryArgs) error

	// Command GetCookies
	//
	// Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the cookies field.
	GetCookies(context.Context) (*cdpcmd.PageGetCookiesReply, error)

	// Command DeleteCookie
	//
	// Deletes browser cookie with given name, domain and path.
	DeleteCookie(context.Context, *cdpcmd.PageDeleteCookieArgs) error

	// Command GetResourceTree
	//
	// Returns present frame / resource tree structure.
	GetResourceTree(context.Context) (*cdpcmd.PageGetResourceTreeReply, error)

	// Command GetResourceContent
	//
	// Returns content of the given resource.
	GetResourceContent(context.Context, *cdpcmd.PageGetResourceContentArgs) (*cdpcmd.PageGetResourceContentReply, error)

	// Command SearchInResource
	//
	// Searches for given string in resource content.
	SearchInResource(context.Context, *cdpcmd.PageSearchInResourceArgs) (*cdpcmd.PageSearchInResourceReply, error)

	// Command SetDocumentContent
	//
	// Sets given markup as the document's HTML.
	SetDocumentContent(context.Context, *cdpcmd.PageSetDocumentContentArgs) error

	// Command SetDeviceMetricsOverride
	//
	// Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).
	SetDeviceMetricsOverride(context.Context, *cdpcmd.PageSetDeviceMetricsOverrideArgs) error

	// Command ClearDeviceMetricsOverride
	//
	// Clears the overriden device metrics.
	ClearDeviceMetricsOverride(context.Context) error

	// Command SetGeolocationOverride
	//
	// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.
	SetGeolocationOverride(context.Context, *cdpcmd.PageSetGeolocationOverrideArgs) error

	// Command ClearGeolocationOverride
	//
	// Clears the overriden Geolocation Position and Error.
	ClearGeolocationOverride(context.Context) error

	// Command SetDeviceOrientationOverride
	//
	// Overrides the Device Orientation.
	SetDeviceOrientationOverride(context.Context, *cdpcmd.PageSetDeviceOrientationOverrideArgs) error

	// Command ClearDeviceOrientationOverride
	//
	// Clears the overridden Device Orientation.
	ClearDeviceOrientationOverride(context.Context) error

	// Command SetTouchEmulationEnabled
	//
	// Toggles mouse event-based touch event emulation.
	SetTouchEmulationEnabled(context.Context, *cdpcmd.PageSetTouchEmulationEnabledArgs) error

	// Command CaptureScreenshot
	//
	// Capture page screenshot.
	CaptureScreenshot(context.Context, *cdpcmd.PageCaptureScreenshotArgs) (*cdpcmd.PageCaptureScreenshotReply, error)

	// Command PrintToPDF
	//
	// Print page as pdf.
	PrintToPDF(context.Context) (*cdpcmd.PagePrintToPDFReply, error)

	// Command StartScreencast
	//
	// Starts sending each frame using the screencastFrame event.
	StartScreencast(context.Context, *cdpcmd.PageStartScreencastArgs) error

	// Command StopScreencast
	//
	// Stops sending each frame in the screencastFrame.
	StopScreencast(context.Context) error

	// Command ScreencastFrameAck
	//
	// Acknowledges that a screencast frame has been received by the frontend.
	ScreencastFrameAck(context.Context, *cdpcmd.PageScreencastFrameAckArgs) error

	// Command HandleJavaScriptDialog
	//
	// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
	HandleJavaScriptDialog(context.Context, *cdpcmd.PageHandleJavaScriptDialogArgs) error

	// Command SetColorPickerEnabled
	//
	// Shows / hides color picker
	SetColorPickerEnabled(context.Context, *cdpcmd.PageSetColorPickerEnabledArgs) error

	// Command ConfigureOverlay
	//
	// Configures overlay.
	ConfigureOverlay(context.Context, *cdpcmd.PageConfigureOverlayArgs) error

	// Command GetAppManifest
	//
	//
	GetAppManifest(context.Context) (*cdpcmd.PageGetAppManifestReply, error)

	// Command RequestAppBanner
	//
	//
	RequestAppBanner(context.Context) error

	// Command SetControlNavigations
	//
	// Toggles navigation throttling which allows programatic control over navigation and redirect response.
	SetControlNavigations(context.Context, *cdpcmd.PageSetControlNavigationsArgs) error

	// Command ProcessNavigation
	//
	// Should be sent in response to a navigationRequested or a redirectRequested event, telling the browser how to handle the navigation.
	ProcessNavigation(context.Context, *cdpcmd.PageProcessNavigationArgs) error

	// Command GetLayoutMetrics
	//
	// Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
	GetLayoutMetrics(context.Context) (*cdpcmd.PageGetLayoutMetricsReply, error)

	// Event DOMContentEventFired
	//
	//
	DOMContentEventFired(context.Context) (cdpevent.PageDOMContentEventFiredClient, error)

	// Event LoadEventFired
	//
	//
	LoadEventFired(context.Context) (cdpevent.PageLoadEventFiredClient, error)

	// Event FrameAttached
	//
	// Fired when frame has been attached to its parent.
	FrameAttached(context.Context) (cdpevent.PageFrameAttachedClient, error)

	// Event FrameNavigated
	//
	// Fired once navigation of the frame has completed. Frame is now associated with the new loader.
	FrameNavigated(context.Context) (cdpevent.PageFrameNavigatedClient, error)

	// Event FrameDetached
	//
	// Fired when frame has been detached from its parent.
	FrameDetached(context.Context) (cdpevent.PageFrameDetachedClient, error)

	// Event FrameStartedLoading
	//
	// Fired when frame has started loading.
	FrameStartedLoading(context.Context) (cdpevent.PageFrameStartedLoadingClient, error)

	// Event FrameStoppedLoading
	//
	// Fired when frame has stopped loading.
	FrameStoppedLoading(context.Context) (cdpevent.PageFrameStoppedLoadingClient, error)

	// Event FrameScheduledNavigation
	//
	// Fired when frame schedules a potential navigation.
	FrameScheduledNavigation(context.Context) (cdpevent.PageFrameScheduledNavigationClient, error)

	// Event FrameClearedScheduledNavigation
	//
	// Fired when frame no longer has a scheduled navigation.
	FrameClearedScheduledNavigation(context.Context) (cdpevent.PageFrameClearedScheduledNavigationClient, error)

	// Event FrameResized
	//
	//
	FrameResized(context.Context) (cdpevent.PageFrameResizedClient, error)

	// Event JavascriptDialogOpening
	//
	// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.
	JavascriptDialogOpening(context.Context) (cdpevent.PageJavascriptDialogOpeningClient, error)

	// Event JavascriptDialogClosed
	//
	// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed.
	JavascriptDialogClosed(context.Context) (cdpevent.PageJavascriptDialogClosedClient, error)

	// Event ScreencastFrame
	//
	// Compressed image data requested by the startScreencast.
	ScreencastFrame(context.Context) (cdpevent.PageScreencastFrameClient, error)

	// Event ScreencastVisibilityChanged
	//
	// Fired when the page with currently enabled screencast was shown or hidden .
	ScreencastVisibilityChanged(context.Context) (cdpevent.PageScreencastVisibilityChangedClient, error)

	// Event ColorPicked
	//
	// Fired when a color has been picked.
	ColorPicked(context.Context) (cdpevent.PageColorPickedClient, error)

	// Event InterstitialShown
	//
	// Fired when interstitial page was shown
	InterstitialShown(context.Context) (cdpevent.PageInterstitialShownClient, error)

	// Event InterstitialHidden
	//
	// Fired when interstitial page was hidden
	InterstitialHidden(context.Context) (cdpevent.PageInterstitialHiddenClient, error)

	// Event NavigationRequested
	//
	// Fired when a navigation is started if navigation throttles are enabled.  The navigation will be deferred until processNavigation is called.
	NavigationRequested(context.Context) (cdpevent.PageNavigationRequestedClient, error)
}

// pageDomain implements the Page domain.
type pageDomain struct{ conn *rpcc.Conn }

func (d *pageDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "Enable", Err: err}
	}
	return
}

func (d *pageDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "Disable", Err: err}
	}
	return
}

func (d *pageDomain) AddScriptToEvaluateOnLoad(ctx context.Context, args *cdpcmd.PageAddScriptToEvaluateOnLoadArgs) (reply *cdpcmd.PageAddScriptToEvaluateOnLoadReply, err error) {
	reply = new(cdpcmd.PageAddScriptToEvaluateOnLoadReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageAddScriptToEvaluateOnLoad.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "AddScriptToEvaluateOnLoad", Err: err}
	}
	return
}

// NewPageAddScriptToEvaluateOnLoadArgs initializes the arguments for AddScriptToEvaluateOnLoad.
func NewPageAddScriptToEvaluateOnLoadArgs(scriptSource string) *cdpcmd.PageAddScriptToEvaluateOnLoadArgs {
	args := new(cdpcmd.PageAddScriptToEvaluateOnLoadArgs)
	args.ScriptSource = scriptSource
	return args
}

func (d *pageDomain) RemoveScriptToEvaluateOnLoad(ctx context.Context, args *cdpcmd.PageRemoveScriptToEvaluateOnLoadArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageRemoveScriptToEvaluateOnLoad.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "RemoveScriptToEvaluateOnLoad", Err: err}
	}
	return
}

// NewPageRemoveScriptToEvaluateOnLoadArgs initializes the arguments for RemoveScriptToEvaluateOnLoad.
func NewPageRemoveScriptToEvaluateOnLoadArgs(identifier cdptype.PageScriptIdentifier) *cdpcmd.PageRemoveScriptToEvaluateOnLoadArgs {
	args := new(cdpcmd.PageRemoveScriptToEvaluateOnLoadArgs)
	args.Identifier = identifier
	return args
}

func (d *pageDomain) SetAutoAttachToCreatedPages(ctx context.Context, args *cdpcmd.PageSetAutoAttachToCreatedPagesArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageSetAutoAttachToCreatedPages.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SetAutoAttachToCreatedPages", Err: err}
	}
	return
}

// NewPageSetAutoAttachToCreatedPagesArgs initializes the arguments for SetAutoAttachToCreatedPages.
func NewPageSetAutoAttachToCreatedPagesArgs(autoAttach bool) *cdpcmd.PageSetAutoAttachToCreatedPagesArgs {
	args := new(cdpcmd.PageSetAutoAttachToCreatedPagesArgs)
	args.AutoAttach = autoAttach
	return args
}

func (d *pageDomain) Reload(ctx context.Context, args *cdpcmd.PageReloadArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageReload.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "Reload", Err: err}
	}
	return
}

// NewPageReloadArgs initializes the arguments for Reload.
func NewPageReloadArgs() *cdpcmd.PageReloadArgs {
	args := new(cdpcmd.PageReloadArgs)

	return args
}

func (d *pageDomain) Navigate(ctx context.Context, args *cdpcmd.PageNavigateArgs) (reply *cdpcmd.PageNavigateReply, err error) {
	reply = new(cdpcmd.PageNavigateReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageNavigate.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "Navigate", Err: err}
	}
	return
}

// NewPageNavigateArgs initializes the arguments for Navigate.
func NewPageNavigateArgs(url string) *cdpcmd.PageNavigateArgs {
	args := new(cdpcmd.PageNavigateArgs)
	args.URL = url
	return args
}

func (d *pageDomain) StopLoading(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageStopLoading.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "StopLoading", Err: err}
	}
	return
}

func (d *pageDomain) GetNavigationHistory(ctx context.Context) (reply *cdpcmd.PageGetNavigationHistoryReply, err error) {
	reply = new(cdpcmd.PageGetNavigationHistoryReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageGetNavigationHistory.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "GetNavigationHistory", Err: err}
	}
	return
}

func (d *pageDomain) NavigateToHistoryEntry(ctx context.Context, args *cdpcmd.PageNavigateToHistoryEntryArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageNavigateToHistoryEntry.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "NavigateToHistoryEntry", Err: err}
	}
	return
}

// NewPageNavigateToHistoryEntryArgs initializes the arguments for NavigateToHistoryEntry.
func NewPageNavigateToHistoryEntryArgs(entryID int) *cdpcmd.PageNavigateToHistoryEntryArgs {
	args := new(cdpcmd.PageNavigateToHistoryEntryArgs)
	args.EntryID = entryID
	return args
}

func (d *pageDomain) GetCookies(ctx context.Context) (reply *cdpcmd.PageGetCookiesReply, err error) {
	reply = new(cdpcmd.PageGetCookiesReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageGetCookies.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "GetCookies", Err: err}
	}
	return
}

func (d *pageDomain) DeleteCookie(ctx context.Context, args *cdpcmd.PageDeleteCookieArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageDeleteCookie.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "DeleteCookie", Err: err}
	}
	return
}

// NewPageDeleteCookieArgs initializes the arguments for DeleteCookie.
func NewPageDeleteCookieArgs(cookieName string, url string) *cdpcmd.PageDeleteCookieArgs {
	args := new(cdpcmd.PageDeleteCookieArgs)
	args.CookieName = cookieName
	args.URL = url
	return args
}

func (d *pageDomain) GetResourceTree(ctx context.Context) (reply *cdpcmd.PageGetResourceTreeReply, err error) {
	reply = new(cdpcmd.PageGetResourceTreeReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageGetResourceTree.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "GetResourceTree", Err: err}
	}
	return
}

func (d *pageDomain) GetResourceContent(ctx context.Context, args *cdpcmd.PageGetResourceContentArgs) (reply *cdpcmd.PageGetResourceContentReply, err error) {
	reply = new(cdpcmd.PageGetResourceContentReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageGetResourceContent.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "GetResourceContent", Err: err}
	}
	return
}

// NewPageGetResourceContentArgs initializes the arguments for GetResourceContent.
func NewPageGetResourceContentArgs(frameID cdptype.PageFrameID, url string) *cdpcmd.PageGetResourceContentArgs {
	args := new(cdpcmd.PageGetResourceContentArgs)
	args.FrameID = frameID
	args.URL = url
	return args
}

func (d *pageDomain) SearchInResource(ctx context.Context, args *cdpcmd.PageSearchInResourceArgs) (reply *cdpcmd.PageSearchInResourceReply, err error) {
	reply = new(cdpcmd.PageSearchInResourceReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageSearchInResource.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SearchInResource", Err: err}
	}
	return
}

// NewPageSearchInResourceArgs initializes the arguments for SearchInResource.
func NewPageSearchInResourceArgs(frameID cdptype.PageFrameID, url string, query string) *cdpcmd.PageSearchInResourceArgs {
	args := new(cdpcmd.PageSearchInResourceArgs)
	args.FrameID = frameID
	args.URL = url
	args.Query = query
	return args
}

func (d *pageDomain) SetDocumentContent(ctx context.Context, args *cdpcmd.PageSetDocumentContentArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageSetDocumentContent.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SetDocumentContent", Err: err}
	}
	return
}

// NewPageSetDocumentContentArgs initializes the arguments for SetDocumentContent.
func NewPageSetDocumentContentArgs(frameID cdptype.PageFrameID, html string) *cdpcmd.PageSetDocumentContentArgs {
	args := new(cdpcmd.PageSetDocumentContentArgs)
	args.FrameID = frameID
	args.HTML = html
	return args
}

func (d *pageDomain) SetDeviceMetricsOverride(ctx context.Context, args *cdpcmd.PageSetDeviceMetricsOverrideArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageSetDeviceMetricsOverride.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SetDeviceMetricsOverride", Err: err}
	}
	return
}

// NewPageSetDeviceMetricsOverrideArgs initializes the arguments for SetDeviceMetricsOverride.
func NewPageSetDeviceMetricsOverrideArgs(width int, height int, deviceScaleFactor float64, mobile bool, fitWindow bool) *cdpcmd.PageSetDeviceMetricsOverrideArgs {
	args := new(cdpcmd.PageSetDeviceMetricsOverrideArgs)
	args.Width = width
	args.Height = height
	args.DeviceScaleFactor = deviceScaleFactor
	args.Mobile = mobile
	args.FitWindow = fitWindow
	return args
}

func (d *pageDomain) ClearDeviceMetricsOverride(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageClearDeviceMetricsOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "ClearDeviceMetricsOverride", Err: err}
	}
	return
}

func (d *pageDomain) SetGeolocationOverride(ctx context.Context, args *cdpcmd.PageSetGeolocationOverrideArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageSetGeolocationOverride.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SetGeolocationOverride", Err: err}
	}
	return
}

// NewPageSetGeolocationOverrideArgs initializes the arguments for SetGeolocationOverride.
func NewPageSetGeolocationOverrideArgs() *cdpcmd.PageSetGeolocationOverrideArgs {
	args := new(cdpcmd.PageSetGeolocationOverrideArgs)

	return args
}

func (d *pageDomain) ClearGeolocationOverride(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageClearGeolocationOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "ClearGeolocationOverride", Err: err}
	}
	return
}

func (d *pageDomain) SetDeviceOrientationOverride(ctx context.Context, args *cdpcmd.PageSetDeviceOrientationOverrideArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageSetDeviceOrientationOverride.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SetDeviceOrientationOverride", Err: err}
	}
	return
}

// NewPageSetDeviceOrientationOverrideArgs initializes the arguments for SetDeviceOrientationOverride.
func NewPageSetDeviceOrientationOverrideArgs(alpha float64, beta float64, gamma float64) *cdpcmd.PageSetDeviceOrientationOverrideArgs {
	args := new(cdpcmd.PageSetDeviceOrientationOverrideArgs)
	args.Alpha = alpha
	args.Beta = beta
	args.Gamma = gamma
	return args
}

func (d *pageDomain) ClearDeviceOrientationOverride(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageClearDeviceOrientationOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "ClearDeviceOrientationOverride", Err: err}
	}
	return
}

func (d *pageDomain) SetTouchEmulationEnabled(ctx context.Context, args *cdpcmd.PageSetTouchEmulationEnabledArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageSetTouchEmulationEnabled.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SetTouchEmulationEnabled", Err: err}
	}
	return
}

// NewPageSetTouchEmulationEnabledArgs initializes the arguments for SetTouchEmulationEnabled.
func NewPageSetTouchEmulationEnabledArgs(enabled bool) *cdpcmd.PageSetTouchEmulationEnabledArgs {
	args := new(cdpcmd.PageSetTouchEmulationEnabledArgs)
	args.Enabled = enabled
	return args
}

func (d *pageDomain) CaptureScreenshot(ctx context.Context, args *cdpcmd.PageCaptureScreenshotArgs) (reply *cdpcmd.PageCaptureScreenshotReply, err error) {
	reply = new(cdpcmd.PageCaptureScreenshotReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageCaptureScreenshot.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "CaptureScreenshot", Err: err}
	}
	return
}

// NewPageCaptureScreenshotArgs initializes the arguments for CaptureScreenshot.
func NewPageCaptureScreenshotArgs() *cdpcmd.PageCaptureScreenshotArgs {
	args := new(cdpcmd.PageCaptureScreenshotArgs)

	return args
}

func (d *pageDomain) PrintToPDF(ctx context.Context) (reply *cdpcmd.PagePrintToPDFReply, err error) {
	reply = new(cdpcmd.PagePrintToPDFReply)

	err = rpcc.Invoke(ctx, cdpcmd.PagePrintToPDF.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "PrintToPDF", Err: err}
	}
	return
}

func (d *pageDomain) StartScreencast(ctx context.Context, args *cdpcmd.PageStartScreencastArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageStartScreencast.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "StartScreencast", Err: err}
	}
	return
}

// NewPageStartScreencastArgs initializes the arguments for StartScreencast.
func NewPageStartScreencastArgs() *cdpcmd.PageStartScreencastArgs {
	args := new(cdpcmd.PageStartScreencastArgs)

	return args
}

func (d *pageDomain) StopScreencast(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageStopScreencast.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "StopScreencast", Err: err}
	}
	return
}

func (d *pageDomain) ScreencastFrameAck(ctx context.Context, args *cdpcmd.PageScreencastFrameAckArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageScreencastFrameAck.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "ScreencastFrameAck", Err: err}
	}
	return
}

// NewPageScreencastFrameAckArgs initializes the arguments for ScreencastFrameAck.
func NewPageScreencastFrameAckArgs(sessionID int) *cdpcmd.PageScreencastFrameAckArgs {
	args := new(cdpcmd.PageScreencastFrameAckArgs)
	args.SessionID = sessionID
	return args
}

func (d *pageDomain) HandleJavaScriptDialog(ctx context.Context, args *cdpcmd.PageHandleJavaScriptDialogArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageHandleJavaScriptDialog.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "HandleJavaScriptDialog", Err: err}
	}
	return
}

// NewPageHandleJavaScriptDialogArgs initializes the arguments for HandleJavaScriptDialog.
func NewPageHandleJavaScriptDialogArgs(accept bool) *cdpcmd.PageHandleJavaScriptDialogArgs {
	args := new(cdpcmd.PageHandleJavaScriptDialogArgs)
	args.Accept = accept
	return args
}

func (d *pageDomain) SetColorPickerEnabled(ctx context.Context, args *cdpcmd.PageSetColorPickerEnabledArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageSetColorPickerEnabled.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SetColorPickerEnabled", Err: err}
	}
	return
}

// NewPageSetColorPickerEnabledArgs initializes the arguments for SetColorPickerEnabled.
func NewPageSetColorPickerEnabledArgs(enabled bool) *cdpcmd.PageSetColorPickerEnabledArgs {
	args := new(cdpcmd.PageSetColorPickerEnabledArgs)
	args.Enabled = enabled
	return args
}

func (d *pageDomain) ConfigureOverlay(ctx context.Context, args *cdpcmd.PageConfigureOverlayArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageConfigureOverlay.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "ConfigureOverlay", Err: err}
	}
	return
}

// NewPageConfigureOverlayArgs initializes the arguments for ConfigureOverlay.
func NewPageConfigureOverlayArgs() *cdpcmd.PageConfigureOverlayArgs {
	args := new(cdpcmd.PageConfigureOverlayArgs)

	return args
}

func (d *pageDomain) GetAppManifest(ctx context.Context) (reply *cdpcmd.PageGetAppManifestReply, err error) {
	reply = new(cdpcmd.PageGetAppManifestReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageGetAppManifest.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "GetAppManifest", Err: err}
	}
	return
}

func (d *pageDomain) RequestAppBanner(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageRequestAppBanner.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "RequestAppBanner", Err: err}
	}
	return
}

func (d *pageDomain) SetControlNavigations(ctx context.Context, args *cdpcmd.PageSetControlNavigationsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageSetControlNavigations.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "SetControlNavigations", Err: err}
	}
	return
}

// NewPageSetControlNavigationsArgs initializes the arguments for SetControlNavigations.
func NewPageSetControlNavigationsArgs(enabled bool) *cdpcmd.PageSetControlNavigationsArgs {
	args := new(cdpcmd.PageSetControlNavigationsArgs)
	args.Enabled = enabled
	return args
}

func (d *pageDomain) ProcessNavigation(ctx context.Context, args *cdpcmd.PageProcessNavigationArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.PageProcessNavigation.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "ProcessNavigation", Err: err}
	}
	return
}

// NewPageProcessNavigationArgs initializes the arguments for ProcessNavigation.
func NewPageProcessNavigationArgs(response cdptype.PageNavigationResponse, navigationID int) *cdpcmd.PageProcessNavigationArgs {
	args := new(cdpcmd.PageProcessNavigationArgs)
	args.Response = response
	args.NavigationID = navigationID
	return args
}

func (d *pageDomain) GetLayoutMetrics(ctx context.Context) (reply *cdpcmd.PageGetLayoutMetricsReply, err error) {
	reply = new(cdpcmd.PageGetLayoutMetricsReply)

	err = rpcc.Invoke(ctx, cdpcmd.PageGetLayoutMetrics.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Page", Op: "GetLayoutMetrics", Err: err}
	}
	return
}

func (d *pageDomain) DOMContentEventFired(ctx context.Context) (cdpevent.PageDOMContentEventFiredClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageDOMContentEventFired.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageDOMContentEventFiredClient{Stream: s}, nil
}

// pageDOMContentEventFiredClient implements PageDOMContentEventFiredClient.
type pageDOMContentEventFiredClient struct{ rpcc.Stream }

func (c *pageDOMContentEventFiredClient) Recv() (*cdpevent.PageDOMContentEventFiredReply, error) {
	event := new(cdpevent.PageDOMContentEventFiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "DOMContentEventFired Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) LoadEventFired(ctx context.Context) (cdpevent.PageLoadEventFiredClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageLoadEventFired.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageLoadEventFiredClient{Stream: s}, nil
}

// pageLoadEventFiredClient implements PageLoadEventFiredClient.
type pageLoadEventFiredClient struct{ rpcc.Stream }

func (c *pageLoadEventFiredClient) Recv() (*cdpevent.PageLoadEventFiredReply, error) {
	event := new(cdpevent.PageLoadEventFiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "LoadEventFired Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) FrameAttached(ctx context.Context) (cdpevent.PageFrameAttachedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameAttached.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageFrameAttachedClient{Stream: s}, nil
}

// pageFrameAttachedClient implements PageFrameAttachedClient.
type pageFrameAttachedClient struct{ rpcc.Stream }

func (c *pageFrameAttachedClient) Recv() (*cdpevent.PageFrameAttachedReply, error) {
	event := new(cdpevent.PageFrameAttachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "FrameAttached Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) FrameNavigated(ctx context.Context) (cdpevent.PageFrameNavigatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameNavigated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageFrameNavigatedClient{Stream: s}, nil
}

// pageFrameNavigatedClient implements PageFrameNavigatedClient.
type pageFrameNavigatedClient struct{ rpcc.Stream }

func (c *pageFrameNavigatedClient) Recv() (*cdpevent.PageFrameNavigatedReply, error) {
	event := new(cdpevent.PageFrameNavigatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "FrameNavigated Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) FrameDetached(ctx context.Context) (cdpevent.PageFrameDetachedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameDetached.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageFrameDetachedClient{Stream: s}, nil
}

// pageFrameDetachedClient implements PageFrameDetachedClient.
type pageFrameDetachedClient struct{ rpcc.Stream }

func (c *pageFrameDetachedClient) Recv() (*cdpevent.PageFrameDetachedReply, error) {
	event := new(cdpevent.PageFrameDetachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "FrameDetached Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) FrameStartedLoading(ctx context.Context) (cdpevent.PageFrameStartedLoadingClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameStartedLoading.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageFrameStartedLoadingClient{Stream: s}, nil
}

// pageFrameStartedLoadingClient implements PageFrameStartedLoadingClient.
type pageFrameStartedLoadingClient struct{ rpcc.Stream }

func (c *pageFrameStartedLoadingClient) Recv() (*cdpevent.PageFrameStartedLoadingReply, error) {
	event := new(cdpevent.PageFrameStartedLoadingReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "FrameStartedLoading Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) FrameStoppedLoading(ctx context.Context) (cdpevent.PageFrameStoppedLoadingClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameStoppedLoading.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageFrameStoppedLoadingClient{Stream: s}, nil
}

// pageFrameStoppedLoadingClient implements PageFrameStoppedLoadingClient.
type pageFrameStoppedLoadingClient struct{ rpcc.Stream }

func (c *pageFrameStoppedLoadingClient) Recv() (*cdpevent.PageFrameStoppedLoadingReply, error) {
	event := new(cdpevent.PageFrameStoppedLoadingReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "FrameStoppedLoading Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) FrameScheduledNavigation(ctx context.Context) (cdpevent.PageFrameScheduledNavigationClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameScheduledNavigation.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageFrameScheduledNavigationClient{Stream: s}, nil
}

// pageFrameScheduledNavigationClient implements PageFrameScheduledNavigationClient.
type pageFrameScheduledNavigationClient struct{ rpcc.Stream }

func (c *pageFrameScheduledNavigationClient) Recv() (*cdpevent.PageFrameScheduledNavigationReply, error) {
	event := new(cdpevent.PageFrameScheduledNavigationReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "FrameScheduledNavigation Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) FrameClearedScheduledNavigation(ctx context.Context) (cdpevent.PageFrameClearedScheduledNavigationClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameClearedScheduledNavigation.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageFrameClearedScheduledNavigationClient{Stream: s}, nil
}

// pageFrameClearedScheduledNavigationClient implements PageFrameClearedScheduledNavigationClient.
type pageFrameClearedScheduledNavigationClient struct{ rpcc.Stream }

func (c *pageFrameClearedScheduledNavigationClient) Recv() (*cdpevent.PageFrameClearedScheduledNavigationReply, error) {
	event := new(cdpevent.PageFrameClearedScheduledNavigationReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "FrameClearedScheduledNavigation Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) FrameResized(ctx context.Context) (cdpevent.PageFrameResizedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameResized.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageFrameResizedClient{Stream: s}, nil
}

// pageFrameResizedClient implements PageFrameResizedClient.
type pageFrameResizedClient struct{ rpcc.Stream }

func (c *pageFrameResizedClient) Recv() (*cdpevent.PageFrameResizedReply, error) {
	event := new(cdpevent.PageFrameResizedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "FrameResized Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) JavascriptDialogOpening(ctx context.Context) (cdpevent.PageJavascriptDialogOpeningClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageJavascriptDialogOpening.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageJavascriptDialogOpeningClient{Stream: s}, nil
}

// pageJavascriptDialogOpeningClient implements PageJavascriptDialogOpeningClient.
type pageJavascriptDialogOpeningClient struct{ rpcc.Stream }

func (c *pageJavascriptDialogOpeningClient) Recv() (*cdpevent.PageJavascriptDialogOpeningReply, error) {
	event := new(cdpevent.PageJavascriptDialogOpeningReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "JavascriptDialogOpening Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) JavascriptDialogClosed(ctx context.Context) (cdpevent.PageJavascriptDialogClosedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageJavascriptDialogClosed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageJavascriptDialogClosedClient{Stream: s}, nil
}

// pageJavascriptDialogClosedClient implements PageJavascriptDialogClosedClient.
type pageJavascriptDialogClosedClient struct{ rpcc.Stream }

func (c *pageJavascriptDialogClosedClient) Recv() (*cdpevent.PageJavascriptDialogClosedReply, error) {
	event := new(cdpevent.PageJavascriptDialogClosedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "JavascriptDialogClosed Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) ScreencastFrame(ctx context.Context) (cdpevent.PageScreencastFrameClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageScreencastFrame.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageScreencastFrameClient{Stream: s}, nil
}

// pageScreencastFrameClient implements PageScreencastFrameClient.
type pageScreencastFrameClient struct{ rpcc.Stream }

func (c *pageScreencastFrameClient) Recv() (*cdpevent.PageScreencastFrameReply, error) {
	event := new(cdpevent.PageScreencastFrameReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "ScreencastFrame Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) ScreencastVisibilityChanged(ctx context.Context) (cdpevent.PageScreencastVisibilityChangedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageScreencastVisibilityChanged.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageScreencastVisibilityChangedClient{Stream: s}, nil
}

// pageScreencastVisibilityChangedClient implements PageScreencastVisibilityChangedClient.
type pageScreencastVisibilityChangedClient struct{ rpcc.Stream }

func (c *pageScreencastVisibilityChangedClient) Recv() (*cdpevent.PageScreencastVisibilityChangedReply, error) {
	event := new(cdpevent.PageScreencastVisibilityChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "ScreencastVisibilityChanged Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) ColorPicked(ctx context.Context) (cdpevent.PageColorPickedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageColorPicked.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageColorPickedClient{Stream: s}, nil
}

// pageColorPickedClient implements PageColorPickedClient.
type pageColorPickedClient struct{ rpcc.Stream }

func (c *pageColorPickedClient) Recv() (*cdpevent.PageColorPickedReply, error) {
	event := new(cdpevent.PageColorPickedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "ColorPicked Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) InterstitialShown(ctx context.Context) (cdpevent.PageInterstitialShownClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageInterstitialShown.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageInterstitialShownClient{Stream: s}, nil
}

// pageInterstitialShownClient implements PageInterstitialShownClient.
type pageInterstitialShownClient struct{ rpcc.Stream }

func (c *pageInterstitialShownClient) Recv() (*cdpevent.PageInterstitialShownReply, error) {
	event := new(cdpevent.PageInterstitialShownReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "InterstitialShown Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) InterstitialHidden(ctx context.Context) (cdpevent.PageInterstitialHiddenClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageInterstitialHidden.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageInterstitialHiddenClient{Stream: s}, nil
}

// pageInterstitialHiddenClient implements PageInterstitialHiddenClient.
type pageInterstitialHiddenClient struct{ rpcc.Stream }

func (c *pageInterstitialHiddenClient) Recv() (*cdpevent.PageInterstitialHiddenReply, error) {
	event := new(cdpevent.PageInterstitialHiddenReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "InterstitialHidden Recv", Err: err}
	}
	return event, nil
}

func (d *pageDomain) NavigationRequested(ctx context.Context) (cdpevent.PageNavigationRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageNavigationRequested.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &pageNavigationRequestedClient{Stream: s}, nil
}

// pageNavigationRequestedClient implements PageNavigationRequestedClient.
type pageNavigationRequestedClient struct{ rpcc.Stream }

func (c *pageNavigationRequestedClient) Recv() (*cdpevent.PageNavigationRequestedReply, error) {
	event := new(cdpevent.PageNavigationRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Page", Op: "NavigationRequested Recv", Err: err}
	}
	return event, nil
}

// The Profiler domain.
type Profiler interface {
	// Command Enable
	//
	//
	Enable(context.Context) error

	// Command Disable
	//
	//
	Disable(context.Context) error

	// Command SetSamplingInterval
	//
	// Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
	SetSamplingInterval(context.Context, *cdpcmd.ProfilerSetSamplingIntervalArgs) error

	// Command Start
	//
	//
	Start(context.Context) error

	// Command Stop
	//
	//
	Stop(context.Context) (*cdpcmd.ProfilerStopReply, error)

	// Command StartPreciseCoverage
	//
	// Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
	StartPreciseCoverage(context.Context) error

	// Command StopPreciseCoverage
	//
	// Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
	StopPreciseCoverage(context.Context) error

	// Command TakePreciseCoverage
	//
	// Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
	TakePreciseCoverage(context.Context) (*cdpcmd.ProfilerTakePreciseCoverageReply, error)

	// Command GetBestEffortCoverage
	//
	// Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
	GetBestEffortCoverage(context.Context) (*cdpcmd.ProfilerGetBestEffortCoverageReply, error)

	// Event ConsoleProfileStarted
	//
	// Sent when new profile recodring is started using console.profile() call.
	ConsoleProfileStarted(context.Context) (cdpevent.ProfilerConsoleProfileStartedClient, error)

	// Event ConsoleProfileFinished
	//
	//
	ConsoleProfileFinished(context.Context) (cdpevent.ProfilerConsoleProfileFinishedClient, error)
}

// profilerDomain implements the Profiler domain.
type profilerDomain struct{ conn *rpcc.Conn }

func (d *profilerDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "Enable", Err: err}
	}
	return
}

func (d *profilerDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "Disable", Err: err}
	}
	return
}

func (d *profilerDomain) SetSamplingInterval(ctx context.Context, args *cdpcmd.ProfilerSetSamplingIntervalArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerSetSamplingInterval.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "SetSamplingInterval", Err: err}
	}
	return
}

// NewProfilerSetSamplingIntervalArgs initializes the arguments for SetSamplingInterval.
func NewProfilerSetSamplingIntervalArgs(interval int) *cdpcmd.ProfilerSetSamplingIntervalArgs {
	args := new(cdpcmd.ProfilerSetSamplingIntervalArgs)
	args.Interval = interval
	return args
}

func (d *profilerDomain) Start(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerStart.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "Start", Err: err}
	}
	return
}

func (d *profilerDomain) Stop(ctx context.Context) (reply *cdpcmd.ProfilerStopReply, err error) {
	reply = new(cdpcmd.ProfilerStopReply)

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerStop.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "Stop", Err: err}
	}
	return
}

func (d *profilerDomain) StartPreciseCoverage(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerStartPreciseCoverage.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "StartPreciseCoverage", Err: err}
	}
	return
}

func (d *profilerDomain) StopPreciseCoverage(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerStopPreciseCoverage.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "StopPreciseCoverage", Err: err}
	}
	return
}

func (d *profilerDomain) TakePreciseCoverage(ctx context.Context) (reply *cdpcmd.ProfilerTakePreciseCoverageReply, err error) {
	reply = new(cdpcmd.ProfilerTakePreciseCoverageReply)

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerTakePreciseCoverage.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "TakePreciseCoverage", Err: err}
	}
	return
}

func (d *profilerDomain) GetBestEffortCoverage(ctx context.Context) (reply *cdpcmd.ProfilerGetBestEffortCoverageReply, err error) {
	reply = new(cdpcmd.ProfilerGetBestEffortCoverageReply)

	err = rpcc.Invoke(ctx, cdpcmd.ProfilerGetBestEffortCoverage.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Profiler", Op: "GetBestEffortCoverage", Err: err}
	}
	return
}

func (d *profilerDomain) ConsoleProfileStarted(ctx context.Context) (cdpevent.ProfilerConsoleProfileStartedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ProfilerConsoleProfileStarted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &profilerConsoleProfileStartedClient{Stream: s}, nil
}

// profilerConsoleProfileStartedClient implements ProfilerConsoleProfileStartedClient.
type profilerConsoleProfileStartedClient struct{ rpcc.Stream }

func (c *profilerConsoleProfileStartedClient) Recv() (*cdpevent.ProfilerConsoleProfileStartedReply, error) {
	event := new(cdpevent.ProfilerConsoleProfileStartedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Profiler", Op: "ConsoleProfileStarted Recv", Err: err}
	}
	return event, nil
}

func (d *profilerDomain) ConsoleProfileFinished(ctx context.Context) (cdpevent.ProfilerConsoleProfileFinishedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ProfilerConsoleProfileFinished.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &profilerConsoleProfileFinishedClient{Stream: s}, nil
}

// profilerConsoleProfileFinishedClient implements ProfilerConsoleProfileFinishedClient.
type profilerConsoleProfileFinishedClient struct{ rpcc.Stream }

func (c *profilerConsoleProfileFinishedClient) Recv() (*cdpevent.ProfilerConsoleProfileFinishedReply, error) {
	event := new(cdpevent.ProfilerConsoleProfileFinishedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Profiler", Op: "ConsoleProfileFinished Recv", Err: err}
	}
	return event, nil
}

// The Rendering domain. This domain allows to control rendering of the page.
type Rendering interface {
	// Command SetShowPaintRects
	//
	// Requests that backend shows paint rectangles
	SetShowPaintRects(context.Context, *cdpcmd.RenderingSetShowPaintRectsArgs) error

	// Command SetShowDebugBorders
	//
	// Requests that backend shows debug borders on layers
	SetShowDebugBorders(context.Context, *cdpcmd.RenderingSetShowDebugBordersArgs) error

	// Command SetShowFPSCounter
	//
	// Requests that backend shows the FPS counter
	SetShowFPSCounter(context.Context, *cdpcmd.RenderingSetShowFPSCounterArgs) error

	// Command SetShowScrollBottleneckRects
	//
	// Requests that backend shows scroll bottleneck rects
	SetShowScrollBottleneckRects(context.Context, *cdpcmd.RenderingSetShowScrollBottleneckRectsArgs) error

	// Command SetShowViewportSizeOnResize
	//
	// Paints viewport size upon main frame resize.
	SetShowViewportSizeOnResize(context.Context, *cdpcmd.RenderingSetShowViewportSizeOnResizeArgs) error
}

// renderingDomain implements the Rendering domain.
type renderingDomain struct{ conn *rpcc.Conn }

func (d *renderingDomain) SetShowPaintRects(ctx context.Context, args *cdpcmd.RenderingSetShowPaintRectsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RenderingSetShowPaintRects.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Rendering", Op: "SetShowPaintRects", Err: err}
	}
	return
}

// NewRenderingSetShowPaintRectsArgs initializes the arguments for SetShowPaintRects.
func NewRenderingSetShowPaintRectsArgs(result bool) *cdpcmd.RenderingSetShowPaintRectsArgs {
	args := new(cdpcmd.RenderingSetShowPaintRectsArgs)
	args.Result = result
	return args
}

func (d *renderingDomain) SetShowDebugBorders(ctx context.Context, args *cdpcmd.RenderingSetShowDebugBordersArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RenderingSetShowDebugBorders.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Rendering", Op: "SetShowDebugBorders", Err: err}
	}
	return
}

// NewRenderingSetShowDebugBordersArgs initializes the arguments for SetShowDebugBorders.
func NewRenderingSetShowDebugBordersArgs(show bool) *cdpcmd.RenderingSetShowDebugBordersArgs {
	args := new(cdpcmd.RenderingSetShowDebugBordersArgs)
	args.Show = show
	return args
}

func (d *renderingDomain) SetShowFPSCounter(ctx context.Context, args *cdpcmd.RenderingSetShowFPSCounterArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RenderingSetShowFPSCounter.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Rendering", Op: "SetShowFPSCounter", Err: err}
	}
	return
}

// NewRenderingSetShowFPSCounterArgs initializes the arguments for SetShowFPSCounter.
func NewRenderingSetShowFPSCounterArgs(show bool) *cdpcmd.RenderingSetShowFPSCounterArgs {
	args := new(cdpcmd.RenderingSetShowFPSCounterArgs)
	args.Show = show
	return args
}

func (d *renderingDomain) SetShowScrollBottleneckRects(ctx context.Context, args *cdpcmd.RenderingSetShowScrollBottleneckRectsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RenderingSetShowScrollBottleneckRects.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Rendering", Op: "SetShowScrollBottleneckRects", Err: err}
	}
	return
}

// NewRenderingSetShowScrollBottleneckRectsArgs initializes the arguments for SetShowScrollBottleneckRects.
func NewRenderingSetShowScrollBottleneckRectsArgs(show bool) *cdpcmd.RenderingSetShowScrollBottleneckRectsArgs {
	args := new(cdpcmd.RenderingSetShowScrollBottleneckRectsArgs)
	args.Show = show
	return args
}

func (d *renderingDomain) SetShowViewportSizeOnResize(ctx context.Context, args *cdpcmd.RenderingSetShowViewportSizeOnResizeArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RenderingSetShowViewportSizeOnResize.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Rendering", Op: "SetShowViewportSizeOnResize", Err: err}
	}
	return
}

// NewRenderingSetShowViewportSizeOnResizeArgs initializes the arguments for SetShowViewportSizeOnResize.
func NewRenderingSetShowViewportSizeOnResizeArgs(show bool) *cdpcmd.RenderingSetShowViewportSizeOnResizeArgs {
	args := new(cdpcmd.RenderingSetShowViewportSizeOnResizeArgs)
	args.Show = show
	return args
}

// The Runtime domain. Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.
type Runtime interface {
	// Command Evaluate
	//
	// Evaluates expression on global object.
	Evaluate(context.Context, *cdpcmd.RuntimeEvaluateArgs) (*cdpcmd.RuntimeEvaluateReply, error)

	// Command AwaitPromise
	//
	// Add handler to promise with given promise object id.
	AwaitPromise(context.Context, *cdpcmd.RuntimeAwaitPromiseArgs) (*cdpcmd.RuntimeAwaitPromiseReply, error)

	// Command CallFunctionOn
	//
	// Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
	CallFunctionOn(context.Context, *cdpcmd.RuntimeCallFunctionOnArgs) (*cdpcmd.RuntimeCallFunctionOnReply, error)

	// Command GetProperties
	//
	// Returns properties of a given object. Object group of the result is inherited from the target object.
	GetProperties(context.Context, *cdpcmd.RuntimeGetPropertiesArgs) (*cdpcmd.RuntimeGetPropertiesReply, error)

	// Command ReleaseObject
	//
	// Releases remote object with given id.
	ReleaseObject(context.Context, *cdpcmd.RuntimeReleaseObjectArgs) error

	// Command ReleaseObjectGroup
	//
	// Releases all remote objects that belong to a given group.
	ReleaseObjectGroup(context.Context, *cdpcmd.RuntimeReleaseObjectGroupArgs) error

	// Command RunIfWaitingForDebugger
	//
	// Tells inspected instance to run if it was waiting for debugger to attach.
	RunIfWaitingForDebugger(context.Context) error

	// Command Enable
	//
	// Enables reporting of execution contexts creation by means of executionContextCreated event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables reporting of execution contexts creation.
	Disable(context.Context) error

	// Command DiscardConsoleEntries
	//
	// Discards collected exceptions and console API calls.
	DiscardConsoleEntries(context.Context) error

	// Command SetCustomObjectFormatterEnabled
	//
	//
	SetCustomObjectFormatterEnabled(context.Context, *cdpcmd.RuntimeSetCustomObjectFormatterEnabledArgs) error

	// Command CompileScript
	//
	// Compiles expression.
	CompileScript(context.Context, *cdpcmd.RuntimeCompileScriptArgs) (*cdpcmd.RuntimeCompileScriptReply, error)

	// Command RunScript
	//
	// Runs script with given id in a given context.
	RunScript(context.Context, *cdpcmd.RuntimeRunScriptArgs) (*cdpcmd.RuntimeRunScriptReply, error)

	// Event ExecutionContextCreated
	//
	// Issued when new execution context is created.
	ExecutionContextCreated(context.Context) (cdpevent.RuntimeExecutionContextCreatedClient, error)

	// Event ExecutionContextDestroyed
	//
	// Issued when execution context is destroyed.
	ExecutionContextDestroyed(context.Context) (cdpevent.RuntimeExecutionContextDestroyedClient, error)

	// Event ExecutionContextsCleared
	//
	// Issued when all executionContexts were cleared in browser
	ExecutionContextsCleared(context.Context) (cdpevent.RuntimeExecutionContextsClearedClient, error)

	// Event ExceptionThrown
	//
	// Issued when exception was thrown and unhandled.
	ExceptionThrown(context.Context) (cdpevent.RuntimeExceptionThrownClient, error)

	// Event ExceptionRevoked
	//
	// Issued when unhandled exception was revoked.
	ExceptionRevoked(context.Context) (cdpevent.RuntimeExceptionRevokedClient, error)

	// Event ConsoleAPICalled
	//
	// Issued when console API was called.
	ConsoleAPICalled(context.Context) (cdpevent.RuntimeConsoleAPICalledClient, error)

	// Event InspectRequested
	//
	// Issued when object should be inspected (for example, as a result of inspect() command line API call).
	InspectRequested(context.Context) (cdpevent.RuntimeInspectRequestedClient, error)
}

// runtimeDomain implements the Runtime domain.
type runtimeDomain struct{ conn *rpcc.Conn }

func (d *runtimeDomain) Evaluate(ctx context.Context, args *cdpcmd.RuntimeEvaluateArgs) (reply *cdpcmd.RuntimeEvaluateReply, err error) {
	reply = new(cdpcmd.RuntimeEvaluateReply)

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeEvaluate.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "Evaluate", Err: err}
	}
	return
}

// NewRuntimeEvaluateArgs initializes the arguments for Evaluate.
func NewRuntimeEvaluateArgs(expression string) *cdpcmd.RuntimeEvaluateArgs {
	args := new(cdpcmd.RuntimeEvaluateArgs)
	args.Expression = expression
	return args
}

func (d *runtimeDomain) AwaitPromise(ctx context.Context, args *cdpcmd.RuntimeAwaitPromiseArgs) (reply *cdpcmd.RuntimeAwaitPromiseReply, err error) {
	reply = new(cdpcmd.RuntimeAwaitPromiseReply)

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeAwaitPromise.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "AwaitPromise", Err: err}
	}
	return
}

// NewRuntimeAwaitPromiseArgs initializes the arguments for AwaitPromise.
func NewRuntimeAwaitPromiseArgs(promiseObjectID cdptype.RuntimeRemoteObjectID) *cdpcmd.RuntimeAwaitPromiseArgs {
	args := new(cdpcmd.RuntimeAwaitPromiseArgs)
	args.PromiseObjectID = promiseObjectID
	return args
}

func (d *runtimeDomain) CallFunctionOn(ctx context.Context, args *cdpcmd.RuntimeCallFunctionOnArgs) (reply *cdpcmd.RuntimeCallFunctionOnReply, err error) {
	reply = new(cdpcmd.RuntimeCallFunctionOnReply)

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeCallFunctionOn.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "CallFunctionOn", Err: err}
	}
	return
}

// NewRuntimeCallFunctionOnArgs initializes the arguments for CallFunctionOn.
func NewRuntimeCallFunctionOnArgs(objectID cdptype.RuntimeRemoteObjectID, functionDeclaration string) *cdpcmd.RuntimeCallFunctionOnArgs {
	args := new(cdpcmd.RuntimeCallFunctionOnArgs)
	args.ObjectID = objectID
	args.FunctionDeclaration = functionDeclaration
	return args
}

func (d *runtimeDomain) GetProperties(ctx context.Context, args *cdpcmd.RuntimeGetPropertiesArgs) (reply *cdpcmd.RuntimeGetPropertiesReply, err error) {
	reply = new(cdpcmd.RuntimeGetPropertiesReply)

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeGetProperties.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "GetProperties", Err: err}
	}
	return
}

// NewRuntimeGetPropertiesArgs initializes the arguments for GetProperties.
func NewRuntimeGetPropertiesArgs(objectID cdptype.RuntimeRemoteObjectID) *cdpcmd.RuntimeGetPropertiesArgs {
	args := new(cdpcmd.RuntimeGetPropertiesArgs)
	args.ObjectID = objectID
	return args
}

func (d *runtimeDomain) ReleaseObject(ctx context.Context, args *cdpcmd.RuntimeReleaseObjectArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeReleaseObject.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "ReleaseObject", Err: err}
	}
	return
}

// NewRuntimeReleaseObjectArgs initializes the arguments for ReleaseObject.
func NewRuntimeReleaseObjectArgs(objectID cdptype.RuntimeRemoteObjectID) *cdpcmd.RuntimeReleaseObjectArgs {
	args := new(cdpcmd.RuntimeReleaseObjectArgs)
	args.ObjectID = objectID
	return args
}

func (d *runtimeDomain) ReleaseObjectGroup(ctx context.Context, args *cdpcmd.RuntimeReleaseObjectGroupArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeReleaseObjectGroup.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "ReleaseObjectGroup", Err: err}
	}
	return
}

// NewRuntimeReleaseObjectGroupArgs initializes the arguments for ReleaseObjectGroup.
func NewRuntimeReleaseObjectGroupArgs(objectGroup string) *cdpcmd.RuntimeReleaseObjectGroupArgs {
	args := new(cdpcmd.RuntimeReleaseObjectGroupArgs)
	args.ObjectGroup = objectGroup
	return args
}

func (d *runtimeDomain) RunIfWaitingForDebugger(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeRunIfWaitingForDebugger.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "RunIfWaitingForDebugger", Err: err}
	}
	return
}

func (d *runtimeDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "Enable", Err: err}
	}
	return
}

func (d *runtimeDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "Disable", Err: err}
	}
	return
}

func (d *runtimeDomain) DiscardConsoleEntries(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeDiscardConsoleEntries.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "DiscardConsoleEntries", Err: err}
	}
	return
}

func (d *runtimeDomain) SetCustomObjectFormatterEnabled(ctx context.Context, args *cdpcmd.RuntimeSetCustomObjectFormatterEnabledArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeSetCustomObjectFormatterEnabled.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "SetCustomObjectFormatterEnabled", Err: err}
	}
	return
}

// NewRuntimeSetCustomObjectFormatterEnabledArgs initializes the arguments for SetCustomObjectFormatterEnabled.
func NewRuntimeSetCustomObjectFormatterEnabledArgs(enabled bool) *cdpcmd.RuntimeSetCustomObjectFormatterEnabledArgs {
	args := new(cdpcmd.RuntimeSetCustomObjectFormatterEnabledArgs)
	args.Enabled = enabled
	return args
}

func (d *runtimeDomain) CompileScript(ctx context.Context, args *cdpcmd.RuntimeCompileScriptArgs) (reply *cdpcmd.RuntimeCompileScriptReply, err error) {
	reply = new(cdpcmd.RuntimeCompileScriptReply)

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeCompileScript.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "CompileScript", Err: err}
	}
	return
}

// NewRuntimeCompileScriptArgs initializes the arguments for CompileScript.
func NewRuntimeCompileScriptArgs(expression string, sourceURL string, persistScript bool) *cdpcmd.RuntimeCompileScriptArgs {
	args := new(cdpcmd.RuntimeCompileScriptArgs)
	args.Expression = expression
	args.SourceURL = sourceURL
	args.PersistScript = persistScript
	return args
}

func (d *runtimeDomain) RunScript(ctx context.Context, args *cdpcmd.RuntimeRunScriptArgs) (reply *cdpcmd.RuntimeRunScriptReply, err error) {
	reply = new(cdpcmd.RuntimeRunScriptReply)

	err = rpcc.Invoke(ctx, cdpcmd.RuntimeRunScript.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Runtime", Op: "RunScript", Err: err}
	}
	return
}

// NewRuntimeRunScriptArgs initializes the arguments for RunScript.
func NewRuntimeRunScriptArgs(scriptID cdptype.RuntimeScriptID) *cdpcmd.RuntimeRunScriptArgs {
	args := new(cdpcmd.RuntimeRunScriptArgs)
	args.ScriptID = scriptID
	return args
}

func (d *runtimeDomain) ExecutionContextCreated(ctx context.Context) (cdpevent.RuntimeExecutionContextCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExecutionContextCreated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &runtimeExecutionContextCreatedClient{Stream: s}, nil
}

// runtimeExecutionContextCreatedClient implements RuntimeExecutionContextCreatedClient.
type runtimeExecutionContextCreatedClient struct{ rpcc.Stream }

func (c *runtimeExecutionContextCreatedClient) Recv() (*cdpevent.RuntimeExecutionContextCreatedReply, error) {
	event := new(cdpevent.RuntimeExecutionContextCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Runtime", Op: "ExecutionContextCreated Recv", Err: err}
	}
	return event, nil
}

func (d *runtimeDomain) ExecutionContextDestroyed(ctx context.Context) (cdpevent.RuntimeExecutionContextDestroyedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExecutionContextDestroyed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &runtimeExecutionContextDestroyedClient{Stream: s}, nil
}

// runtimeExecutionContextDestroyedClient implements RuntimeExecutionContextDestroyedClient.
type runtimeExecutionContextDestroyedClient struct{ rpcc.Stream }

func (c *runtimeExecutionContextDestroyedClient) Recv() (*cdpevent.RuntimeExecutionContextDestroyedReply, error) {
	event := new(cdpevent.RuntimeExecutionContextDestroyedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Runtime", Op: "ExecutionContextDestroyed Recv", Err: err}
	}
	return event, nil
}

func (d *runtimeDomain) ExecutionContextsCleared(ctx context.Context) (cdpevent.RuntimeExecutionContextsClearedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExecutionContextsCleared.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &runtimeExecutionContextsClearedClient{Stream: s}, nil
}

// runtimeExecutionContextsClearedClient implements RuntimeExecutionContextsClearedClient.
type runtimeExecutionContextsClearedClient struct{ rpcc.Stream }

func (c *runtimeExecutionContextsClearedClient) Recv() (*cdpevent.RuntimeExecutionContextsClearedReply, error) {
	event := new(cdpevent.RuntimeExecutionContextsClearedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Runtime", Op: "ExecutionContextsCleared Recv", Err: err}
	}
	return event, nil
}

func (d *runtimeDomain) ExceptionThrown(ctx context.Context) (cdpevent.RuntimeExceptionThrownClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExceptionThrown.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &runtimeExceptionThrownClient{Stream: s}, nil
}

// runtimeExceptionThrownClient implements RuntimeExceptionThrownClient.
type runtimeExceptionThrownClient struct{ rpcc.Stream }

func (c *runtimeExceptionThrownClient) Recv() (*cdpevent.RuntimeExceptionThrownReply, error) {
	event := new(cdpevent.RuntimeExceptionThrownReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Runtime", Op: "ExceptionThrown Recv", Err: err}
	}
	return event, nil
}

func (d *runtimeDomain) ExceptionRevoked(ctx context.Context) (cdpevent.RuntimeExceptionRevokedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExceptionRevoked.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &runtimeExceptionRevokedClient{Stream: s}, nil
}

// runtimeExceptionRevokedClient implements RuntimeExceptionRevokedClient.
type runtimeExceptionRevokedClient struct{ rpcc.Stream }

func (c *runtimeExceptionRevokedClient) Recv() (*cdpevent.RuntimeExceptionRevokedReply, error) {
	event := new(cdpevent.RuntimeExceptionRevokedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Runtime", Op: "ExceptionRevoked Recv", Err: err}
	}
	return event, nil
}

func (d *runtimeDomain) ConsoleAPICalled(ctx context.Context) (cdpevent.RuntimeConsoleAPICalledClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeConsoleAPICalled.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &runtimeConsoleAPICalledClient{Stream: s}, nil
}

// runtimeConsoleAPICalledClient implements RuntimeConsoleAPICalledClient.
type runtimeConsoleAPICalledClient struct{ rpcc.Stream }

func (c *runtimeConsoleAPICalledClient) Recv() (*cdpevent.RuntimeConsoleAPICalledReply, error) {
	event := new(cdpevent.RuntimeConsoleAPICalledReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Runtime", Op: "ConsoleAPICalled Recv", Err: err}
	}
	return event, nil
}

func (d *runtimeDomain) InspectRequested(ctx context.Context) (cdpevent.RuntimeInspectRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeInspectRequested.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &runtimeInspectRequestedClient{Stream: s}, nil
}

// runtimeInspectRequestedClient implements RuntimeInspectRequestedClient.
type runtimeInspectRequestedClient struct{ rpcc.Stream }

func (c *runtimeInspectRequestedClient) Recv() (*cdpevent.RuntimeInspectRequestedReply, error) {
	event := new(cdpevent.RuntimeInspectRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Runtime", Op: "InspectRequested Recv", Err: err}
	}
	return event, nil
}

// The Schema domain. Provides information about the protocol schema.
type Schema interface {
	// Command GetDomains
	//
	// Returns supported domains.
	GetDomains(context.Context) (*cdpcmd.SchemaGetDomainsReply, error)
}

// schemaDomain implements the Schema domain.
type schemaDomain struct{ conn *rpcc.Conn }

func (d *schemaDomain) GetDomains(ctx context.Context) (reply *cdpcmd.SchemaGetDomainsReply, err error) {
	reply = new(cdpcmd.SchemaGetDomainsReply)

	err = rpcc.Invoke(ctx, cdpcmd.SchemaGetDomains.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Schema", Op: "GetDomains", Err: err}
	}
	return
}

// The Security domain. Security
type Security interface {
	// Command Enable
	//
	// Enables tracking security state changes.
	Enable(context.Context) error

	// Command Disable
	//
	// Disables tracking security state changes.
	Disable(context.Context) error

	// Command ShowCertificateViewer
	//
	// Displays native dialog with the certificate details.
	ShowCertificateViewer(context.Context) error

	// Event SecurityStateChanged
	//
	// The security state of the page changed.
	SecurityStateChanged(context.Context) (cdpevent.SecurityStateChangedClient, error)
}

// securityDomain implements the Security domain.
type securityDomain struct{ conn *rpcc.Conn }

func (d *securityDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.SecurityEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Security", Op: "Enable", Err: err}
	}
	return
}

func (d *securityDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.SecurityDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Security", Op: "Disable", Err: err}
	}
	return
}

func (d *securityDomain) ShowCertificateViewer(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.SecurityShowCertificateViewer.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Security", Op: "ShowCertificateViewer", Err: err}
	}
	return
}

func (d *securityDomain) SecurityStateChanged(ctx context.Context) (cdpevent.SecurityStateChangedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.SecurityStateChanged.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &securitySecurityStateChangedClient{Stream: s}, nil
}

// securitySecurityStateChangedClient implements SecurityStateChangedClient.
type securitySecurityStateChangedClient struct{ rpcc.Stream }

func (c *securitySecurityStateChangedClient) Recv() (*cdpevent.SecurityStateChangedReply, error) {
	event := new(cdpevent.SecurityStateChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Security", Op: "SecurityStateChanged Recv", Err: err}
	}
	return event, nil
}

// The ServiceWorker domain.
type ServiceWorker interface {
	// Command Enable
	//
	//
	Enable(context.Context) error

	// Command Disable
	//
	//
	Disable(context.Context) error

	// Command Unregister
	//
	//
	Unregister(context.Context, *cdpcmd.ServiceWorkerUnregisterArgs) error

	// Command UpdateRegistration
	//
	//
	UpdateRegistration(context.Context, *cdpcmd.ServiceWorkerUpdateRegistrationArgs) error

	// Command StartWorker
	//
	//
	StartWorker(context.Context, *cdpcmd.ServiceWorkerStartWorkerArgs) error

	// Command SkipWaiting
	//
	//
	SkipWaiting(context.Context, *cdpcmd.ServiceWorkerSkipWaitingArgs) error

	// Command StopWorker
	//
	//
	StopWorker(context.Context, *cdpcmd.ServiceWorkerStopWorkerArgs) error

	// Command InspectWorker
	//
	//
	InspectWorker(context.Context, *cdpcmd.ServiceWorkerInspectWorkerArgs) error

	// Command SetForceUpdateOnPageLoad
	//
	//
	SetForceUpdateOnPageLoad(context.Context, *cdpcmd.ServiceWorkerSetForceUpdateOnPageLoadArgs) error

	// Command DeliverPushMessage
	//
	//
	DeliverPushMessage(context.Context, *cdpcmd.ServiceWorkerDeliverPushMessageArgs) error

	// Command DispatchSyncEvent
	//
	//
	DispatchSyncEvent(context.Context, *cdpcmd.ServiceWorkerDispatchSyncEventArgs) error

	// Event WorkerRegistrationUpdated
	//
	//
	WorkerRegistrationUpdated(context.Context) (cdpevent.ServiceWorkerWorkerRegistrationUpdatedClient, error)

	// Event WorkerVersionUpdated
	//
	//
	WorkerVersionUpdated(context.Context) (cdpevent.ServiceWorkerWorkerVersionUpdatedClient, error)

	// Event WorkerErrorReported
	//
	//
	WorkerErrorReported(context.Context) (cdpevent.ServiceWorkerWorkerErrorReportedClient, error)
}

// serviceworkerDomain implements the ServiceWorker domain.
type serviceworkerDomain struct{ conn *rpcc.Conn }

func (d *serviceworkerDomain) Enable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "Enable", Err: err}
	}
	return
}

func (d *serviceworkerDomain) Disable(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "Disable", Err: err}
	}
	return
}

func (d *serviceworkerDomain) Unregister(ctx context.Context, args *cdpcmd.ServiceWorkerUnregisterArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerUnregister.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "Unregister", Err: err}
	}
	return
}

// NewServiceWorkerUnregisterArgs initializes the arguments for Unregister.
func NewServiceWorkerUnregisterArgs(scopeURL string) *cdpcmd.ServiceWorkerUnregisterArgs {
	args := new(cdpcmd.ServiceWorkerUnregisterArgs)
	args.ScopeURL = scopeURL
	return args
}

func (d *serviceworkerDomain) UpdateRegistration(ctx context.Context, args *cdpcmd.ServiceWorkerUpdateRegistrationArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerUpdateRegistration.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "UpdateRegistration", Err: err}
	}
	return
}

// NewServiceWorkerUpdateRegistrationArgs initializes the arguments for UpdateRegistration.
func NewServiceWorkerUpdateRegistrationArgs(scopeURL string) *cdpcmd.ServiceWorkerUpdateRegistrationArgs {
	args := new(cdpcmd.ServiceWorkerUpdateRegistrationArgs)
	args.ScopeURL = scopeURL
	return args
}

func (d *serviceworkerDomain) StartWorker(ctx context.Context, args *cdpcmd.ServiceWorkerStartWorkerArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerStartWorker.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "StartWorker", Err: err}
	}
	return
}

// NewServiceWorkerStartWorkerArgs initializes the arguments for StartWorker.
func NewServiceWorkerStartWorkerArgs(scopeURL string) *cdpcmd.ServiceWorkerStartWorkerArgs {
	args := new(cdpcmd.ServiceWorkerStartWorkerArgs)
	args.ScopeURL = scopeURL
	return args
}

func (d *serviceworkerDomain) SkipWaiting(ctx context.Context, args *cdpcmd.ServiceWorkerSkipWaitingArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerSkipWaiting.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "SkipWaiting", Err: err}
	}
	return
}

// NewServiceWorkerSkipWaitingArgs initializes the arguments for SkipWaiting.
func NewServiceWorkerSkipWaitingArgs(scopeURL string) *cdpcmd.ServiceWorkerSkipWaitingArgs {
	args := new(cdpcmd.ServiceWorkerSkipWaitingArgs)
	args.ScopeURL = scopeURL
	return args
}

func (d *serviceworkerDomain) StopWorker(ctx context.Context, args *cdpcmd.ServiceWorkerStopWorkerArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerStopWorker.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "StopWorker", Err: err}
	}
	return
}

// NewServiceWorkerStopWorkerArgs initializes the arguments for StopWorker.
func NewServiceWorkerStopWorkerArgs(versionID string) *cdpcmd.ServiceWorkerStopWorkerArgs {
	args := new(cdpcmd.ServiceWorkerStopWorkerArgs)
	args.VersionID = versionID
	return args
}

func (d *serviceworkerDomain) InspectWorker(ctx context.Context, args *cdpcmd.ServiceWorkerInspectWorkerArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerInspectWorker.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "InspectWorker", Err: err}
	}
	return
}

// NewServiceWorkerInspectWorkerArgs initializes the arguments for InspectWorker.
func NewServiceWorkerInspectWorkerArgs(versionID string) *cdpcmd.ServiceWorkerInspectWorkerArgs {
	args := new(cdpcmd.ServiceWorkerInspectWorkerArgs)
	args.VersionID = versionID
	return args
}

func (d *serviceworkerDomain) SetForceUpdateOnPageLoad(ctx context.Context, args *cdpcmd.ServiceWorkerSetForceUpdateOnPageLoadArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerSetForceUpdateOnPageLoad.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "SetForceUpdateOnPageLoad", Err: err}
	}
	return
}

// NewServiceWorkerSetForceUpdateOnPageLoadArgs initializes the arguments for SetForceUpdateOnPageLoad.
func NewServiceWorkerSetForceUpdateOnPageLoadArgs(forceUpdateOnPageLoad bool) *cdpcmd.ServiceWorkerSetForceUpdateOnPageLoadArgs {
	args := new(cdpcmd.ServiceWorkerSetForceUpdateOnPageLoadArgs)
	args.ForceUpdateOnPageLoad = forceUpdateOnPageLoad
	return args
}

func (d *serviceworkerDomain) DeliverPushMessage(ctx context.Context, args *cdpcmd.ServiceWorkerDeliverPushMessageArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerDeliverPushMessage.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "DeliverPushMessage", Err: err}
	}
	return
}

// NewServiceWorkerDeliverPushMessageArgs initializes the arguments for DeliverPushMessage.
func NewServiceWorkerDeliverPushMessageArgs(origin string, registrationID string, data string) *cdpcmd.ServiceWorkerDeliverPushMessageArgs {
	args := new(cdpcmd.ServiceWorkerDeliverPushMessageArgs)
	args.Origin = origin
	args.RegistrationID = registrationID
	args.Data = data
	return args
}

func (d *serviceworkerDomain) DispatchSyncEvent(ctx context.Context, args *cdpcmd.ServiceWorkerDispatchSyncEventArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerDispatchSyncEvent.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "ServiceWorker", Op: "DispatchSyncEvent", Err: err}
	}
	return
}

// NewServiceWorkerDispatchSyncEventArgs initializes the arguments for DispatchSyncEvent.
func NewServiceWorkerDispatchSyncEventArgs(origin string, registrationID string, tag string, lastChance bool) *cdpcmd.ServiceWorkerDispatchSyncEventArgs {
	args := new(cdpcmd.ServiceWorkerDispatchSyncEventArgs)
	args.Origin = origin
	args.RegistrationID = registrationID
	args.Tag = tag
	args.LastChance = lastChance
	return args
}

func (d *serviceworkerDomain) WorkerRegistrationUpdated(ctx context.Context) (cdpevent.ServiceWorkerWorkerRegistrationUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ServiceWorkerWorkerRegistrationUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &serviceworkerWorkerRegistrationUpdatedClient{Stream: s}, nil
}

// serviceworkerWorkerRegistrationUpdatedClient implements ServiceWorkerWorkerRegistrationUpdatedClient.
type serviceworkerWorkerRegistrationUpdatedClient struct{ rpcc.Stream }

func (c *serviceworkerWorkerRegistrationUpdatedClient) Recv() (*cdpevent.ServiceWorkerWorkerRegistrationUpdatedReply, error) {
	event := new(cdpevent.ServiceWorkerWorkerRegistrationUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "ServiceWorker", Op: "WorkerRegistrationUpdated Recv", Err: err}
	}
	return event, nil
}

func (d *serviceworkerDomain) WorkerVersionUpdated(ctx context.Context) (cdpevent.ServiceWorkerWorkerVersionUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ServiceWorkerWorkerVersionUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &serviceworkerWorkerVersionUpdatedClient{Stream: s}, nil
}

// serviceworkerWorkerVersionUpdatedClient implements ServiceWorkerWorkerVersionUpdatedClient.
type serviceworkerWorkerVersionUpdatedClient struct{ rpcc.Stream }

func (c *serviceworkerWorkerVersionUpdatedClient) Recv() (*cdpevent.ServiceWorkerWorkerVersionUpdatedReply, error) {
	event := new(cdpevent.ServiceWorkerWorkerVersionUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "ServiceWorker", Op: "WorkerVersionUpdated Recv", Err: err}
	}
	return event, nil
}

func (d *serviceworkerDomain) WorkerErrorReported(ctx context.Context) (cdpevent.ServiceWorkerWorkerErrorReportedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ServiceWorkerWorkerErrorReported.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &serviceworkerWorkerErrorReportedClient{Stream: s}, nil
}

// serviceworkerWorkerErrorReportedClient implements ServiceWorkerWorkerErrorReportedClient.
type serviceworkerWorkerErrorReportedClient struct{ rpcc.Stream }

func (c *serviceworkerWorkerErrorReportedClient) Recv() (*cdpevent.ServiceWorkerWorkerErrorReportedReply, error) {
	event := new(cdpevent.ServiceWorkerWorkerErrorReportedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "ServiceWorker", Op: "WorkerErrorReported Recv", Err: err}
	}
	return event, nil
}

// The Storage domain.
type Storage interface {
	// Command ClearDataForOrigin
	//
	// Clears storage for origin.
	ClearDataForOrigin(context.Context, *cdpcmd.StorageClearDataForOriginArgs) error
}

// storageDomain implements the Storage domain.
type storageDomain struct{ conn *rpcc.Conn }

func (d *storageDomain) ClearDataForOrigin(ctx context.Context, args *cdpcmd.StorageClearDataForOriginArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.StorageClearDataForOrigin.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Storage", Op: "ClearDataForOrigin", Err: err}
	}
	return
}

// NewStorageClearDataForOriginArgs initializes the arguments for ClearDataForOrigin.
func NewStorageClearDataForOriginArgs(origin string, storageTypes string) *cdpcmd.StorageClearDataForOriginArgs {
	args := new(cdpcmd.StorageClearDataForOriginArgs)
	args.Origin = origin
	args.StorageTypes = storageTypes
	return args
}

// The SystemInfo domain. The SystemInfo domain defines methods and events for querying low-level system information.
type SystemInfo interface {
	// Command GetInfo
	//
	// Returns information about the system.
	GetInfo(context.Context) (*cdpcmd.SystemInfoGetInfoReply, error)
}

// systeminfoDomain implements the SystemInfo domain.
type systeminfoDomain struct{ conn *rpcc.Conn }

func (d *systeminfoDomain) GetInfo(ctx context.Context) (reply *cdpcmd.SystemInfoGetInfoReply, err error) {
	reply = new(cdpcmd.SystemInfoGetInfoReply)

	err = rpcc.Invoke(ctx, cdpcmd.SystemInfoGetInfo.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "SystemInfo", Op: "GetInfo", Err: err}
	}
	return
}

// The Target domain. Supports additional targets discovery and allows to attach to them.
type Target interface {
	// Command SetDiscoverTargets
	//
	// Controls whether to discover available targets and notify via targetCreated/targetDestroyed events.
	SetDiscoverTargets(context.Context, *cdpcmd.TargetSetDiscoverTargetsArgs) error

	// Command SetAutoAttach
	//
	// Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets.
	SetAutoAttach(context.Context, *cdpcmd.TargetSetAutoAttachArgs) error

	// Command SetAttachToFrames
	//
	//
	SetAttachToFrames(context.Context, *cdpcmd.TargetSetAttachToFramesArgs) error

	// Command SetRemoteLocations
	//
	// Enables target discovery for the specified locations, when setDiscoverTargets was set to true.
	SetRemoteLocations(context.Context, *cdpcmd.TargetSetRemoteLocationsArgs) error

	// Command SendMessageToTarget
	//
	// Sends protocol message to the target with given id.
	SendMessageToTarget(context.Context, *cdpcmd.TargetSendMessageToTargetArgs) error

	// Command GetTargetInfo
	//
	// Returns information about a target.
	GetTargetInfo(context.Context, *cdpcmd.TargetGetTargetInfoArgs) (*cdpcmd.TargetGetTargetInfoReply, error)

	// Command ActivateTarget
	//
	// Activates (focuses) the target.
	ActivateTarget(context.Context, *cdpcmd.TargetActivateTargetArgs) error

	// Command CloseTarget
	//
	// Closes the target. If the target is a page that gets closed too.
	CloseTarget(context.Context, *cdpcmd.TargetCloseTargetArgs) (*cdpcmd.TargetCloseTargetReply, error)

	// Command AttachToTarget
	//
	// Attaches to the target with given id.
	AttachToTarget(context.Context, *cdpcmd.TargetAttachToTargetArgs) (*cdpcmd.TargetAttachToTargetReply, error)

	// Command DetachFromTarget
	//
	// Detaches from the target with given id.
	DetachFromTarget(context.Context, *cdpcmd.TargetDetachFromTargetArgs) error

	// Command CreateBrowserContext
	//
	// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.
	CreateBrowserContext(context.Context) (*cdpcmd.TargetCreateBrowserContextReply, error)

	// Command DisposeBrowserContext
	//
	// Deletes a BrowserContext, will fail of any open page uses it.
	DisposeBrowserContext(context.Context, *cdpcmd.TargetDisposeBrowserContextArgs) (*cdpcmd.TargetDisposeBrowserContextReply, error)

	// Command CreateTarget
	//
	// Creates a new page.
	CreateTarget(context.Context, *cdpcmd.TargetCreateTargetArgs) (*cdpcmd.TargetCreateTargetReply, error)

	// Command GetTargets
	//
	// Retrieves a list of available targets.
	GetTargets(context.Context) (*cdpcmd.TargetGetTargetsReply, error)

	// Event TargetCreated
	//
	// Issued when a possible inspection target is created.
	TargetCreated(context.Context) (cdpevent.TargetCreatedClient, error)

	// Event TargetDestroyed
	//
	// Issued when a target is destroyed.
	TargetDestroyed(context.Context) (cdpevent.TargetDestroyedClient, error)

	// Event AttachedToTarget
	//
	// Issued when attached to target because of auto-attach or attachToTarget command.
	AttachedToTarget(context.Context) (cdpevent.TargetAttachedToTargetClient, error)

	// Event DetachedFromTarget
	//
	// Issued when detached from target for any reason (including detachFromTarget command).
	DetachedFromTarget(context.Context) (cdpevent.TargetDetachedFromTargetClient, error)

	// Event ReceivedMessageFromTarget
	//
	// Notifies about new protocol message from attached target.
	ReceivedMessageFromTarget(context.Context) (cdpevent.TargetReceivedMessageFromTargetClient, error)
}

// targetDomain implements the Target domain.
type targetDomain struct{ conn *rpcc.Conn }

func (d *targetDomain) SetDiscoverTargets(ctx context.Context, args *cdpcmd.TargetSetDiscoverTargetsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TargetSetDiscoverTargets.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "SetDiscoverTargets", Err: err}
	}
	return
}

// NewTargetSetDiscoverTargetsArgs initializes the arguments for SetDiscoverTargets.
func NewTargetSetDiscoverTargetsArgs(discover bool) *cdpcmd.TargetSetDiscoverTargetsArgs {
	args := new(cdpcmd.TargetSetDiscoverTargetsArgs)
	args.Discover = discover
	return args
}

func (d *targetDomain) SetAutoAttach(ctx context.Context, args *cdpcmd.TargetSetAutoAttachArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TargetSetAutoAttach.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "SetAutoAttach", Err: err}
	}
	return
}

// NewTargetSetAutoAttachArgs initializes the arguments for SetAutoAttach.
func NewTargetSetAutoAttachArgs(autoAttach bool, waitForDebuggerOnStart bool) *cdpcmd.TargetSetAutoAttachArgs {
	args := new(cdpcmd.TargetSetAutoAttachArgs)
	args.AutoAttach = autoAttach
	args.WaitForDebuggerOnStart = waitForDebuggerOnStart
	return args
}

func (d *targetDomain) SetAttachToFrames(ctx context.Context, args *cdpcmd.TargetSetAttachToFramesArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TargetSetAttachToFrames.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "SetAttachToFrames", Err: err}
	}
	return
}

// NewTargetSetAttachToFramesArgs initializes the arguments for SetAttachToFrames.
func NewTargetSetAttachToFramesArgs(value bool) *cdpcmd.TargetSetAttachToFramesArgs {
	args := new(cdpcmd.TargetSetAttachToFramesArgs)
	args.Value = value
	return args
}

func (d *targetDomain) SetRemoteLocations(ctx context.Context, args *cdpcmd.TargetSetRemoteLocationsArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TargetSetRemoteLocations.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "SetRemoteLocations", Err: err}
	}
	return
}

// NewTargetSetRemoteLocationsArgs initializes the arguments for SetRemoteLocations.
func NewTargetSetRemoteLocationsArgs(locations []cdptype.TargetRemoteLocation) *cdpcmd.TargetSetRemoteLocationsArgs {
	args := new(cdpcmd.TargetSetRemoteLocationsArgs)
	args.Locations = locations
	return args
}

func (d *targetDomain) SendMessageToTarget(ctx context.Context, args *cdpcmd.TargetSendMessageToTargetArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TargetSendMessageToTarget.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "SendMessageToTarget", Err: err}
	}
	return
}

// NewTargetSendMessageToTargetArgs initializes the arguments for SendMessageToTarget.
func NewTargetSendMessageToTargetArgs(targetID string, message string) *cdpcmd.TargetSendMessageToTargetArgs {
	args := new(cdpcmd.TargetSendMessageToTargetArgs)
	args.TargetID = targetID
	args.Message = message
	return args
}

func (d *targetDomain) GetTargetInfo(ctx context.Context, args *cdpcmd.TargetGetTargetInfoArgs) (reply *cdpcmd.TargetGetTargetInfoReply, err error) {
	reply = new(cdpcmd.TargetGetTargetInfoReply)

	err = rpcc.Invoke(ctx, cdpcmd.TargetGetTargetInfo.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "GetTargetInfo", Err: err}
	}
	return
}

// NewTargetGetTargetInfoArgs initializes the arguments for GetTargetInfo.
func NewTargetGetTargetInfoArgs(targetID cdptype.TargetID) *cdpcmd.TargetGetTargetInfoArgs {
	args := new(cdpcmd.TargetGetTargetInfoArgs)
	args.TargetID = targetID
	return args
}

func (d *targetDomain) ActivateTarget(ctx context.Context, args *cdpcmd.TargetActivateTargetArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TargetActivateTarget.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "ActivateTarget", Err: err}
	}
	return
}

// NewTargetActivateTargetArgs initializes the arguments for ActivateTarget.
func NewTargetActivateTargetArgs(targetID cdptype.TargetID) *cdpcmd.TargetActivateTargetArgs {
	args := new(cdpcmd.TargetActivateTargetArgs)
	args.TargetID = targetID
	return args
}

func (d *targetDomain) CloseTarget(ctx context.Context, args *cdpcmd.TargetCloseTargetArgs) (reply *cdpcmd.TargetCloseTargetReply, err error) {
	reply = new(cdpcmd.TargetCloseTargetReply)

	err = rpcc.Invoke(ctx, cdpcmd.TargetCloseTarget.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "CloseTarget", Err: err}
	}
	return
}

// NewTargetCloseTargetArgs initializes the arguments for CloseTarget.
func NewTargetCloseTargetArgs(targetID cdptype.TargetID) *cdpcmd.TargetCloseTargetArgs {
	args := new(cdpcmd.TargetCloseTargetArgs)
	args.TargetID = targetID
	return args
}

func (d *targetDomain) AttachToTarget(ctx context.Context, args *cdpcmd.TargetAttachToTargetArgs) (reply *cdpcmd.TargetAttachToTargetReply, err error) {
	reply = new(cdpcmd.TargetAttachToTargetReply)

	err = rpcc.Invoke(ctx, cdpcmd.TargetAttachToTarget.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "AttachToTarget", Err: err}
	}
	return
}

// NewTargetAttachToTargetArgs initializes the arguments for AttachToTarget.
func NewTargetAttachToTargetArgs(targetID cdptype.TargetID) *cdpcmd.TargetAttachToTargetArgs {
	args := new(cdpcmd.TargetAttachToTargetArgs)
	args.TargetID = targetID
	return args
}

func (d *targetDomain) DetachFromTarget(ctx context.Context, args *cdpcmd.TargetDetachFromTargetArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TargetDetachFromTarget.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "DetachFromTarget", Err: err}
	}
	return
}

// NewTargetDetachFromTargetArgs initializes the arguments for DetachFromTarget.
func NewTargetDetachFromTargetArgs(targetID cdptype.TargetID) *cdpcmd.TargetDetachFromTargetArgs {
	args := new(cdpcmd.TargetDetachFromTargetArgs)
	args.TargetID = targetID
	return args
}

func (d *targetDomain) CreateBrowserContext(ctx context.Context) (reply *cdpcmd.TargetCreateBrowserContextReply, err error) {
	reply = new(cdpcmd.TargetCreateBrowserContextReply)

	err = rpcc.Invoke(ctx, cdpcmd.TargetCreateBrowserContext.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "CreateBrowserContext", Err: err}
	}
	return
}

func (d *targetDomain) DisposeBrowserContext(ctx context.Context, args *cdpcmd.TargetDisposeBrowserContextArgs) (reply *cdpcmd.TargetDisposeBrowserContextReply, err error) {
	reply = new(cdpcmd.TargetDisposeBrowserContextReply)

	err = rpcc.Invoke(ctx, cdpcmd.TargetDisposeBrowserContext.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "DisposeBrowserContext", Err: err}
	}
	return
}

// NewTargetDisposeBrowserContextArgs initializes the arguments for DisposeBrowserContext.
func NewTargetDisposeBrowserContextArgs(browserContextID cdptype.TargetBrowserContextID) *cdpcmd.TargetDisposeBrowserContextArgs {
	args := new(cdpcmd.TargetDisposeBrowserContextArgs)
	args.BrowserContextID = browserContextID
	return args
}

func (d *targetDomain) CreateTarget(ctx context.Context, args *cdpcmd.TargetCreateTargetArgs) (reply *cdpcmd.TargetCreateTargetReply, err error) {
	reply = new(cdpcmd.TargetCreateTargetReply)

	err = rpcc.Invoke(ctx, cdpcmd.TargetCreateTarget.String(), args, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "CreateTarget", Err: err}
	}
	return
}

// NewTargetCreateTargetArgs initializes the arguments for CreateTarget.
func NewTargetCreateTargetArgs(url string) *cdpcmd.TargetCreateTargetArgs {
	args := new(cdpcmd.TargetCreateTargetArgs)
	args.URL = url
	return args
}

func (d *targetDomain) GetTargets(ctx context.Context) (reply *cdpcmd.TargetGetTargetsReply, err error) {
	reply = new(cdpcmd.TargetGetTargetsReply)

	err = rpcc.Invoke(ctx, cdpcmd.TargetGetTargets.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Target", Op: "GetTargets", Err: err}
	}
	return
}

func (d *targetDomain) TargetCreated(ctx context.Context) (cdpevent.TargetCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetCreated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &targetTargetCreatedClient{Stream: s}, nil
}

// targetTargetCreatedClient implements TargetCreatedClient.
type targetTargetCreatedClient struct{ rpcc.Stream }

func (c *targetTargetCreatedClient) Recv() (*cdpevent.TargetCreatedReply, error) {
	event := new(cdpevent.TargetCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Target", Op: "TargetCreated Recv", Err: err}
	}
	return event, nil
}

func (d *targetDomain) TargetDestroyed(ctx context.Context) (cdpevent.TargetDestroyedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetDestroyed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &targetTargetDestroyedClient{Stream: s}, nil
}

// targetTargetDestroyedClient implements TargetDestroyedClient.
type targetTargetDestroyedClient struct{ rpcc.Stream }

func (c *targetTargetDestroyedClient) Recv() (*cdpevent.TargetDestroyedReply, error) {
	event := new(cdpevent.TargetDestroyedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Target", Op: "TargetDestroyed Recv", Err: err}
	}
	return event, nil
}

func (d *targetDomain) AttachedToTarget(ctx context.Context) (cdpevent.TargetAttachedToTargetClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetAttachedToTarget.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &targetAttachedToTargetClient{Stream: s}, nil
}

// targetAttachedToTargetClient implements TargetAttachedToTargetClient.
type targetAttachedToTargetClient struct{ rpcc.Stream }

func (c *targetAttachedToTargetClient) Recv() (*cdpevent.TargetAttachedToTargetReply, error) {
	event := new(cdpevent.TargetAttachedToTargetReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Target", Op: "AttachedToTarget Recv", Err: err}
	}
	return event, nil
}

func (d *targetDomain) DetachedFromTarget(ctx context.Context) (cdpevent.TargetDetachedFromTargetClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetDetachedFromTarget.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &targetDetachedFromTargetClient{Stream: s}, nil
}

// targetDetachedFromTargetClient implements TargetDetachedFromTargetClient.
type targetDetachedFromTargetClient struct{ rpcc.Stream }

func (c *targetDetachedFromTargetClient) Recv() (*cdpevent.TargetDetachedFromTargetReply, error) {
	event := new(cdpevent.TargetDetachedFromTargetReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Target", Op: "DetachedFromTarget Recv", Err: err}
	}
	return event, nil
}

func (d *targetDomain) ReceivedMessageFromTarget(ctx context.Context) (cdpevent.TargetReceivedMessageFromTargetClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetReceivedMessageFromTarget.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &targetReceivedMessageFromTargetClient{Stream: s}, nil
}

// targetReceivedMessageFromTargetClient implements TargetReceivedMessageFromTargetClient.
type targetReceivedMessageFromTargetClient struct{ rpcc.Stream }

func (c *targetReceivedMessageFromTargetClient) Recv() (*cdpevent.TargetReceivedMessageFromTargetReply, error) {
	event := new(cdpevent.TargetReceivedMessageFromTargetReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Target", Op: "ReceivedMessageFromTarget Recv", Err: err}
	}
	return event, nil
}

// The Tethering domain. The Tethering domain defines methods and events for browser port binding.
type Tethering interface {
	// Command Bind
	//
	// Request browser port binding.
	Bind(context.Context, *cdpcmd.TetheringBindArgs) error

	// Command Unbind
	//
	// Request browser port unbinding.
	Unbind(context.Context, *cdpcmd.TetheringUnbindArgs) error

	// Event Accepted
	//
	// Informs that port was successfully bound and got a specified connection id.
	Accepted(context.Context) (cdpevent.TetheringAcceptedClient, error)
}

// tetheringDomain implements the Tethering domain.
type tetheringDomain struct{ conn *rpcc.Conn }

func (d *tetheringDomain) Bind(ctx context.Context, args *cdpcmd.TetheringBindArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TetheringBind.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Tethering", Op: "Bind", Err: err}
	}
	return
}

// NewTetheringBindArgs initializes the arguments for Bind.
func NewTetheringBindArgs(port int) *cdpcmd.TetheringBindArgs {
	args := new(cdpcmd.TetheringBindArgs)
	args.Port = port
	return args
}

func (d *tetheringDomain) Unbind(ctx context.Context, args *cdpcmd.TetheringUnbindArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TetheringUnbind.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Tethering", Op: "Unbind", Err: err}
	}
	return
}

// NewTetheringUnbindArgs initializes the arguments for Unbind.
func NewTetheringUnbindArgs(port int) *cdpcmd.TetheringUnbindArgs {
	args := new(cdpcmd.TetheringUnbindArgs)
	args.Port = port
	return args
}

func (d *tetheringDomain) Accepted(ctx context.Context) (cdpevent.TetheringAcceptedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TetheringAccepted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &tetheringAcceptedClient{Stream: s}, nil
}

// tetheringAcceptedClient implements TetheringAcceptedClient.
type tetheringAcceptedClient struct{ rpcc.Stream }

func (c *tetheringAcceptedClient) Recv() (*cdpevent.TetheringAcceptedReply, error) {
	event := new(cdpevent.TetheringAcceptedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Tethering", Op: "Accepted Recv", Err: err}
	}
	return event, nil
}

// The Tracing domain.
type Tracing interface {
	// Command Start
	//
	// Start trace events collection.
	Start(context.Context, *cdpcmd.TracingStartArgs) error

	// Command End
	//
	// Stop trace events collection.
	End(context.Context) error

	// Command GetCategories
	//
	// Gets supported tracing categories.
	GetCategories(context.Context) (*cdpcmd.TracingGetCategoriesReply, error)

	// Command RequestMemoryDump
	//
	// Request a global memory dump.
	RequestMemoryDump(context.Context) (*cdpcmd.TracingRequestMemoryDumpReply, error)

	// Command RecordClockSyncMarker
	//
	// Record a clock sync marker in the trace.
	RecordClockSyncMarker(context.Context, *cdpcmd.TracingRecordClockSyncMarkerArgs) error

	// Event DataCollected
	//
	// Contains an bucket of collected trace events. When tracing is stopped collected events will be send as a sequence of dataCollected events followed by tracingComplete event.
	DataCollected(context.Context) (cdpevent.TracingDataCollectedClient, error)

	// Event TracingComplete
	//
	// Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events.
	TracingComplete(context.Context) (cdpevent.TracingCompleteClient, error)

	// Event BufferUsage
	//
	//
	BufferUsage(context.Context) (cdpevent.TracingBufferUsageClient, error)
}

// tracingDomain implements the Tracing domain.
type tracingDomain struct{ conn *rpcc.Conn }

func (d *tracingDomain) Start(ctx context.Context, args *cdpcmd.TracingStartArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TracingStart.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Tracing", Op: "Start", Err: err}
	}
	return
}

// NewTracingStartArgs initializes the arguments for Start.
func NewTracingStartArgs() *cdpcmd.TracingStartArgs {
	args := new(cdpcmd.TracingStartArgs)

	return args
}

func (d *tracingDomain) End(ctx context.Context) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TracingEnd.String(), nil, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Tracing", Op: "End", Err: err}
	}
	return
}

func (d *tracingDomain) GetCategories(ctx context.Context) (reply *cdpcmd.TracingGetCategoriesReply, err error) {
	reply = new(cdpcmd.TracingGetCategoriesReply)

	err = rpcc.Invoke(ctx, cdpcmd.TracingGetCategories.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Tracing", Op: "GetCategories", Err: err}
	}
	return
}

func (d *tracingDomain) RequestMemoryDump(ctx context.Context) (reply *cdpcmd.TracingRequestMemoryDumpReply, err error) {
	reply = new(cdpcmd.TracingRequestMemoryDumpReply)

	err = rpcc.Invoke(ctx, cdpcmd.TracingRequestMemoryDump.String(), nil, reply, d.conn)
	if err != nil {
		err = &Error{Domain: "Tracing", Op: "RequestMemoryDump", Err: err}
	}
	return
}

func (d *tracingDomain) RecordClockSyncMarker(ctx context.Context, args *cdpcmd.TracingRecordClockSyncMarkerArgs) (err error) {

	err = rpcc.Invoke(ctx, cdpcmd.TracingRecordClockSyncMarker.String(), args, nil, d.conn)
	if err != nil {
		err = &Error{Domain: "Tracing", Op: "RecordClockSyncMarker", Err: err}
	}
	return
}

// NewTracingRecordClockSyncMarkerArgs initializes the arguments for RecordClockSyncMarker.
func NewTracingRecordClockSyncMarkerArgs(syncID string) *cdpcmd.TracingRecordClockSyncMarkerArgs {
	args := new(cdpcmd.TracingRecordClockSyncMarkerArgs)
	args.SyncID = syncID
	return args
}

func (d *tracingDomain) DataCollected(ctx context.Context) (cdpevent.TracingDataCollectedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TracingDataCollected.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &tracingDataCollectedClient{Stream: s}, nil
}

// tracingDataCollectedClient implements TracingDataCollectedClient.
type tracingDataCollectedClient struct{ rpcc.Stream }

func (c *tracingDataCollectedClient) Recv() (*cdpevent.TracingDataCollectedReply, error) {
	event := new(cdpevent.TracingDataCollectedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Tracing", Op: "DataCollected Recv", Err: err}
	}
	return event, nil
}

func (d *tracingDomain) TracingComplete(ctx context.Context) (cdpevent.TracingCompleteClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TracingComplete.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &tracingTracingCompleteClient{Stream: s}, nil
}

// tracingTracingCompleteClient implements TracingCompleteClient.
type tracingTracingCompleteClient struct{ rpcc.Stream }

func (c *tracingTracingCompleteClient) Recv() (*cdpevent.TracingCompleteReply, error) {
	event := new(cdpevent.TracingCompleteReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Tracing", Op: "TracingComplete Recv", Err: err}
	}
	return event, nil
}

func (d *tracingDomain) BufferUsage(ctx context.Context) (cdpevent.TracingBufferUsageClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TracingBufferUsage.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &tracingBufferUsageClient{Stream: s}, nil
}

// tracingBufferUsageClient implements TracingBufferUsageClient.
type tracingBufferUsageClient struct{ rpcc.Stream }

func (c *tracingBufferUsageClient) Recv() (*cdpevent.TracingBufferUsageReply, error) {
	event := new(cdpevent.TracingBufferUsageReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &Error{Domain: "Tracing", Op: "BufferUsage Recv", Err: err}
	}
	return event, nil
}
